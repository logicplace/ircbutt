[*
//TODO: --l@
// ie. XdYe{XdYe{XdY}} is the max (no third e)
//TODO: Write test file
//TODO: Write module handler
var limited = false, vars = {}, rollIdx, exprs, prolls;

//Defines
var
OP_DICE   = 1,
OP_POS    = 2,
OP_NEG    = 3,
OP_NOT    = 4,
OP_STR    = 5,
OP_NUM    = 6,
OP_ADD    = 7,
OP_SUB    = 8,
OP_MUL    = 9,
OP_DIV    = 10,
OP_MOD    = 11,
OP_BAND   = 12,
OP_BXOR   = 13,
OP_BOR    = 14,
OP_AND    = 15,
OP_OR     = 16,
OP_XOR    = 17,
OP_EQU    = 18,
OP_NEQ    = 19,
OP_LSS    = 20,
OP_LEQ    = 21,
OP_GTR    = 22,
OP_GEQ    = 23,
OP_MIN    = 36,
OP_MNE    = 37,
OP_MAX    = 38,
OP_XNE    = 39,
OP_SLSS   = 24,
OP_SLEQ   = 25,
OP_SGTR   = 26,
OP_SGEQ   = 27,
OP_COND   = 28,
OP_IDX    = 32,
OP_PARA   = 33,
OP_CTOG   = 34,
OP_IGNR   = 35,
VAL_NUM   = 29,
VAL_STR   = 30,
VAR       = 31
//39 -> 40
;

//Token class
function Token(type){
	this.type = type;
	this.result = null;
	this.resolved = false;
	this.print = "";
	this.highest = 15;
	for(var i=1;i<arguments.length;++i){
		this[i-1] = arguments[i];
	}
}

//Helper functions
function num(val){
	switch(typeof(val)){
		case "string": return val.length;
		case "number": return val;
	}
}

function str(val){
	switch(typeof(val)){
		case "string": return val;
		case "number": return val.toString();
	}
}

function qstr(val){
	return (val.indexOf("'") == -1 ? "'"+val+"'" : '"'+val+'"')
}

function qreal(val){
	switch(typeof(val)){
		case "string": return qstr(val);
		case "number": return val.toString();
	}
}

function varName(va){
	try {
		return {
			"m": "(m)in",
			"x": "ma(x)",
			"a": "(a)vg",
			"r": "(r)oll",
			"z": "expression(z)",
			"s": "(s)et",
			"c": "d(c)ount",
			"y": "zcount(y)"
		}[va];
	} catch(e) {
		return va;
	}
}

function isStr(val){ return typeof(val) == "string"; }
function strrep(astr,c){ var ret = ""; for(var i=0;i<c;++i)ret += astr; return ret; }
function strrev(astr){
	var ret = "";
	for(var i=astr.length-1;i>=0;--i)ret += astr.charAt(i);
	return ret;
}


var curOptions;

function resolve(s,ooo){
	if(curOptions.indexOf(s) != -1){
		for(var i=2;i<arguments.length;++i){
			if(!arguments[i].resolved && arguments[i].highest < ooo){
				return false;
			}
		}
		return true;
	} else return false;
}

function exeExpr(expr, options){
	for(var i=0;i<options.length;++i){
		var c = options.charAt(i),cased;
		if(curOptions.indexOf(c) == -1){
			if((cased = c.toUpperCase()) == c){
				if((cased = c.toLowerCase()) == c){
					curOptions += c;
					continue;
				}
			}
			curOptions = curOptions.replace(cased,c);
		}
	}
	var z = execute(expr);
	vars.z.push(z);
	vars.y = vars.z.length;
	z = qreal(z);
	if(expr.print && expr.print != z){
		if(resolve("p")) exprs.push(z)
		else exprs.push(expr.print+" = "+z);
	}
}

var eachDepth = 0;
function execute(token, doExec){
	var result,res,ooo,print;
	switch(token.type){
		case OP_DICE: {
			//0: Amount; 1: Sides; 2: Each
			var amount, sides, rolls = [], minRoll, maxRoll, average, total
			,right = execute(token[1]), isstr = isStr(right), each = token[2];
			//They have a minimum of 1 either way
			amount = Math.max(1,num(execute(token[0]))); sides = Math.max(1,num(right));
			
			//Enforce limits
			if(limited){
				amount = Math.min(amount,20);
				sides = Math.min(sides,1000);
			}
			
			//Base total
			if(isstr)total = "";
			else total = 0;
			
			if(sides == 1){
				//Quickie for one side rolls
				minRoll = maxRoll = average = right;
				for(var i=0;i<amount;++i){
					rolls.push(1);
					total += right;
				}
			} else {
				var numTotal = 0;
				for(var i=0;i<amount;++i){
					var r = Math.round(Math.random()*(sides-1)+1);
					if(i){
						minRoll = Math.min(minRoll,r);
						maxRoll = Math.max(maxRoll,r);
					} else minRoll = maxRoll = r;
					numTotal += r;
					if(isstr)r = right.charAt(r-1);
					total += r;
					rolls.push(r);
				}
				average = Math.floor(numTotal/sides);
				if(isstr){
					average = right.charAt(average);
					minRoll = right.charAt(minRoll);
					maxRoll = right.charAt(maxRoll);
				}
			}
			
			var rid = rollIdx;
			vars.a[rid] = average; vars.r[rid] = total;
			vars.m[rid] = minRoll; vars.x[rid] = maxRoll;
			vars.c = vars.a.length;
			
			var eprints = [], erolls = [];
			if(each){
				++eachDepth;
				var oldi = vars.i;
				for(var i=0;i<amount;++i){
					rollIdx = rid+1;
					vars.o = rolls[i];
					vars.i = i+1;
					var r = execute(each);
					eprints.push(each.print);
					if(i){
						switch(typeof(total)){
							case "number": {
								r = num(r);
								minRoll = Math.min(minRoll,r);
								maxRoll = Math.max(maxRoll,r);
								break;
							} case "string": {
								r = str(r);
								break;
							}
						}
						total += r;
					} else {
						total = r;
						if(typeof(total) == "number"){
							minRoll = maxRoll = r;
						}
					}
					erolls.push(r);
				}
				vars.i = oldi;
				
				vars.R[rid] = vars.r[rid]; vars.A[rid] = vars.a[rid];
				vars.M[rid] = vars.m[rid]; vars.X[rid] = vars.x[rid];
				if(typeof(total) == "number"){
					vars.a[rid] = Math.floor(total/sides);
					vars.m[rid] = minRoll;
					vars.x[rid] = maxRoll;
				}
				vars.r[rid] = total;
				
				--eachDepth;
			}
			
			//Print for expression
			result = total;
			ooo = 0;
			res = resolve("d",ooo,token[0],token[1]);
			print = token[0].print+"d"+token[1].print;
			//This strips out the added o
			if(each){
				//TODO: --Dv SOMEHOW
				each.print = each.print.replace(/([^'" ]+|'[^']*'|"[^"]*") /,"");
				print += "e{"+each.print+"}";
			}
			
			//Print for rolls
			if(prolls.length <= rollIdx)prolls[rid] = [];
			var tmp = [];
			if(limited && eachDepth > 0){
				tmp.totals = true;
				tmp.push(qreal(total));
			} else {
				tmp.total = qreal(total);
				for(var i=0;i<amount;++i){
					if(resolve("r")){
						if(each)tmp.push(qreal(erolls[i]));
						else tmp.push(qreal(rolls[i]));
					}
					else if(each)tmp.push("("+qreal(rolls[i])+" "
					+eprints[i].replace(/([^'" ]+|'[^']*'|"[^"]*") /,"")+") = "+qreal(erolls[i]));
					else tmp.push(qreal(rolls[i]));
				}
			}
			prolls[rid].push(tmp);
			
			rollIdx = rid + 1;
			break;
		} case OP_POS: {
			//0: Value
			result = Math.abs(num(execute(token[0])));
			ooo = 1;
			res = resolve("u",ooo,token[0]);
			print = "+"+token[0].print;
			break;
		} case OP_NEG: {
			//0: Value
			result = -num(execute(token[0]));
			ooo = 1;
			res = resolve("u",ooo,token[0]);
			print = "-"+token[0].print;
			break;
		} case OP_NOT: {
			//0: Value
			result = execute(token[0])?0:1;
			ooo = 1;
			res = resolve("u",ooo,token[0]);
			print = "~"+token[0].print;
			break;
		} case OP_STR: {
			//0: Value
			result = str(execute(token[0]));
			ooo = 1;
			res = resolve("u",ooo,token[0]);
			print = "@"+token[0].print;
			break;
		} case OP_NUM: {
			//0: Value
			var val = execute(token[0]);
			switch(typeof(val)){
				case "number": result = val; break;
				case "string": result = parseInt(val.replace(/[^0-9]/g,"")); break;
			}
			ooo = 1;
			res = resolve("u",ooo,token[0]);
			print = "#"+token[0].print;
			break;
		} case OP_ADD: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			//Concatenate : Add
			result = (isStr(left) ? left + str(right) : left + num(right));
			ooo = 3;
			res = resolve("s",ooo,token[0],token[1]);
			print = token[0].print+" + "+token[1].print;
			break;
		} case OP_SUB: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				//Remove substring from string : Chop
				result = (isStr(right) ? left.replace(new RegExp(right,"g"),"")
					: (right < 0 ? left.slice(-right) : left.slice(0,-right))
				);
			} else result = left - num(right);
			ooo = 3;
			res = resolve("s",ooo,token[0],token[1]);
			print = token[0].print+" - "+token[1].print;
			break;
		} case OP_MUL: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				//Count occurances of substring in string
				if(isStr(right))result = left.split(right).length-1;
				//Repeat string
				else {
					//Negatives reverse string
					if(right < 0){
						left = strrev(left);
						right *= -1;
					}
					result = (limited ? strrep(left,Math.min(right,20)) : strrep(left,right));
				}
			} else {
				//Numerical multiplication
				result = num(left) * num(right);
			}
			ooo = 2;
			res = resolve("m",ooo,token[0],token[1]);
			print = token[0].print+" * "+token[1].print;
			break;
		} case OP_DIV: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				result = (isStr(right) ? left.match(new RegExp(this.escape(right),"g")).join("")
					: (right < 0 ? left.slice(0,right) : left.slice(right))
				);
			} else {
				//Numerical division
				result = num(left) / num(right);
			}
			ooo = 2;
			res = resolve("m",ooo,token[0],token[1]);
			print = token[0].print+" / "+token[1].print;
			break;
		} case OP_MOD: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				//Formatted string
				result = left.replace(/(^|[^%])%(?!%)-?/g,"$1"+str(right)).replace(/%(%+)/g,"$1");
			} else {
				//Return [correct] modulo (JS's is weird)
				right = num(right);
				result = ((left%right)+right)%right;
			}
			ooo = 2;
			res = resolve("m",ooo,token[0],token[1]);
			print = token[0].print+" % "+token[1].print;
			break;
		} case OP_BAND: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				if(isStr(right)){
					//Return chars that are in both
					result = "";
					for(var i=0;i<left.length;++i){
						if(right.indexOf(left.charAt(i)) != -1)result += left.charAt(i);
					}
				} else {
					var i=0;
					result = "";
					right = Math.abs(right);
					while(right){
						if(right&1)result += left.charAt(i);
						right >>= 1; ++i;
					}
				}
			} else result = left & num(right);
			ooo = 5;
			res = resolve("b",ooo,token[0],token[1]);
			print = token[0].print+" & "+token[1].print;
			break;
		} case OP_BXOR: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left)){
				if(isStr(right)){
					//Return chars that are in both
					result = "";
					for(var i=0;i<left.length;++i){
						if(right.indexOf(left.charAt(i)) == -1)result += left.charAt(i);
					}
				} else {
					var i=0;
					result = "";
					right = Math.abs(right);
					while(right){
						if(!(right&1))result += left.charAt(i);
						right >>= 1; ++i;
					}
				}
			} else result = left ^ num(right);
			ooo = 5;
			res = resolve("b",ooo,token[0],token[1]);
			print = token[0].print+" ^ "+token[1].print;
			break;
		} case OP_BOR: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			if(isStr(left) && isStr(right)){
				var lr = left+right;
				result = "";
				for(var i=0;i<lr.length;++i){
					if(result.indexOf(lr.charAt(i)) != -1)result += lr.charAt(i);
				}
			} else {
				result = num(left) | num(right);
			}
			ooo = 5;
			res = resolve("b",ooo,token[0],token[1]);
			print = token[0].print+" | "+token[1].print;
			break;
		} case OP_AND: {
			//0: Left value; 1: Right value
			result = Number(execute(token[0]) && execute(token[1]));
			ooo = 6;
			res = resolve("a",ooo,token[0],token[1]);
			print = token[0].print+" && "+token[1].print;
			break;
		} case OP_OR: {
			//0: Left value; 1: Right value
			result = Number(execute(token[0]) || execute(token[1]));
			ooo = 7;
			res = resolve("o",ooo,token[0],token[1]);
			print = token[0].print+" || "+token[1].print;
			break;
		} case OP_XOR: {
			//0: Left value; 1: Right value
			result = Number(Boolean(execute(token[0])) != Boolean(execute(token[1])));
			ooo = 7;
			res = resolve("o",ooo,token[0],token[1]);
			print = token[0].print+" ^^ "+token[1].print;
			break;
		} case OP_EQU: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = Number((isStr(left) && isStr(right)) ? left == right : num(left) == num(right));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" == "+token[1].print;
			break;
		} case OP_NEQ: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = Number((isStr(left) && isStr(right)) ? left != right : num(left) != num(right));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" != "+token[1].print;
			break;
		} case OP_LSS: {
			//0: Left value; 1: Right value
			result = Number(num(execute(token[0])) < num(execute(token[1])));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" < "+token[1].print;
			break;
		} case OP_LEQ: {
			//0: Left value; 1: Right value
			result = Number(num(execute(token[0])) <= num(execute(token[1])));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" <= "+token[1].print;
			break;
		} case OP_GTR: {
			//0: Left value; 1: Right value
			result = Number(num(execute(token[0])) > num(execute(token[1])));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" > "+token[1].print;
			break;
		} case OP_GEQ: {
			//0: Left value; 1: Right value
			return Number(num(execute(token[0])) >= num(execute(token[1])));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" >= "+token[1].print;
			break;
		} case OP_MIN: {
			result = (num(left) < num(right) ? left : right);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" <> "+token[1].print;
			break;
		} case OP_MNE: {
			result = (num(left) == num(right) ? 0 : (num(left) < num(right) ? left : right));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" <!> "+token[1].print;
			break;
		} case OP_MAX: {
			result = (num(left) > num(right) ? left : right);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" >< "+token[1].print;
			break;
		} case OP_XNE: {
			result = (num(left) == num(right) ? 0 : (num(left) > num(right) ? left : right));
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" >!< "+token[1].print;
			break;
		} case OP_SLSS: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = (num(left) < num(right) ? left : 0);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" << "+token[1].print;
			break;
		} case OP_SLEQ: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = (num(left) <= num(right) ? left : 0);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" <=< "+token[1].print;
			break;
		} case OP_SGTR: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = (num(left) > num(right) ? left : 0);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" >> "+token[1].print;
			break;
		} case OP_SGEQ: {
			//0: Left value; 1: Right value
			var left = execute(token[0])
			, right = execute(token[1]);
			result = (num(left) >= num(right) ? left : 0);
			ooo = 4;
			res = resolve("c",ooo,token[0],token[1]);
			print = token[0].print+" >=> "+token[1].print;
			break;
		} case OP_COND: {
			//0: Conditional expression; 1: OP_CTOGS or True expression (with no false)
			var bool = Boolean(vars.s = execute(token[0]));
			ooo = 8;
			print = token[0].print+" ?"+(bool?"":":")+" ";
			if(token[1].type == OP_CTOG){
				result = execute(token[1],Number(bool))
				print += token[1].print;
			} else if(bool) {
				result = execute(token[1]);
				print += token[1].print;
			} else {
				result = 0;
				print += "0";
			}
			res = resolve("t",ooo,token[0],token[1]);
			break;
		} case OP_CTOG: {
			//0: Execute this; 1: OP_CTOG list or Ignored expression
			var right = token, i = 0, ret, last;
			if(typeof(doExec) == "undefined")doExec = 1;
			while(right.type == OP_CTOG){
				if((i & 1) != doExec){
					if(right[0] === null){
						ret = 0;
						last = {print: "0"};
					} else ret = execute(last = right[0]);
				}
				++i;
				right = right[1];
			}
			result = ((i & 1) != doExec ? execute(right) : ret);
			ooo = 8;
			res = resolve("t",ooo,token[0],token[1]);
			print = ((i & 1) != doExec ? right : last).print;
			break;
		} case OP_IDX: {
			//0: Token to subscript; 1: Index
			var idx = execute(token[1]);
			if(token[0].type == VAR){
				var vv = vars[token[0][0]];
				idx = num(idx);
				if(Array.isArray(vv)){
					result = (idx > vv.length ? 0 : vv[idx-1]);
				} else result = vv;
				token[0].print = (resolve("n") ? varName(token[0][0]) : token[0][0]);
				token[0].highest = 10;
				token[0].resolved = resolve("v",10,token[0]);
			} else {
				var x = execute(token[0]);
				if(isStr(x)){
					if(isStr(idx)){
						result = x.indexOf(idx)+1;
					} else if(idx < 0) {
						idx = x.length+idx;
						result = (idx < 0 ? '' : x.charAt(idx));
					} else {
						result = (idx > x.length || idx == 0 ? '' : x.charAt(idx-1));
					}
				} else result = x;
			}
			ooo = 9;
			res = resolve("i",ooo,token[0],token[1]);
			print = token[0].print+"["+token[1].print+"]";
			break;
		} case OP_PARA: {
			//0: Expression
			result = execute(token[0]);
			ooo = 0;
			res = resolve("g",ooo,token[0]);
			print = "("+token[0].print+")";
			break;
		} case OP_IGNR: {
			//0: Expression to ignore the print of
			result = execute(token[0]);
			res = false;
			token[0].print = "";
			ooo = 15;
			print = "";
			break;
		} case VAL_NUM: {
			//0: Number
			result = parseInt(token[0]);
			res = true;
			ooo = 15;
			break;
		} case VAL_STR: {
			//0: String
			result = token[0];
			ooo = 15;
			res = true;
			break;
		} case VAR: {
			//0: Variable name
			var vv = vars[token[0]];
			result = (Array.isArray(vv) ? (vv.length ? vv[vv.length-1] : 0) : vv);
			ooo = 10;
			res = resolve("v");
			print = (resolve("n") ? varName(token[0]) : token[0]);
			break;
		}
	}
	token.result = result;
	token.resolved = res;
	token.highest = Math.min(token.highest,ooo);
	if(res){
		token.print = qreal(result);
	} else {
		token.print = print;
	}
	return result;
}

*]



!	' |\t|\n'

	','
	';'
	"d"
	"e"
	"n"
	'\+'
	'\-'
	"!|~|not"                  NOT
	'@'
	'#'
	'\*'
	'/'
	'%'
	"=|==|eq|equ"              EQU
	"!=|~=|ne|neq"             NEQ
	">|gt|gtr"                 GTR
	">=|!<|ge|geq"             GEQ
	"<|lt|lss"                 LSS
	"<=|!>|le|leq"             LEQ
	"<>|mn|min"                MIN
	"<~>|<!>|mn|mne"           MNE
	"><|mx|max"                MAX
	">~<|>!<|xn|xne"           XNE
	'<<'
	'<=<'
	'>>'
	'>=>'
	'&'
	'^'
	'\|'
	"&&|and"                   AND
	"\|\||or"                  OR
	"^^|xor"                   XOR
	'\?'
	':'
	'\('
	'\)'
	'\['
	'\]'
	'\{'
	'\}'
	"\-\-[prgdumscbaotivln@]+" Options   [* %match = %match.slice(2); *]
	'[mxasrzcyMXARoi]'         Variable
	'\'([^\']*)\'|"([^"]*)"'   String    [* %match = %match.slice(1,-1); *]
	'[0-9]+'                   Number
	;

##

ExprList:          ExprList ',' ExprOpts
                 | ExprList ';' ExprOpts
                 | ExprOpts
                 ;

ExprOpts:          Options Expr                       [* exeExpr(%2,%1) *]
                 | Expr                               [* exeExpr(%1,'');  *]
                 |                                    [* exeExpr(new Token(VAL_NUM,0),''); *]
                 ;

/~ Reversed Order of Operations ~/
/~
Expr:              ':' LogicalOrs ':' Expr                   [* %% = %4; *]
                 | ':' LogicalOrs                            [* %% = new Token(VAL_NUM,0); *]
                 | Conditional
                 ;

Conditional:       LogicalOrs '?' LogicalOrs ':' LogicalOrs [* %% = new Token(OP_COND,%1,%3,%5); *]
                 | LogicalOrs '?' ':' LogicalOrs            [* %% = new Token(OP_COND,%1,null,%4); *]
                 | LogicalOrs '?' LogicalOrs                [* %% = new Token(OP_COND,%1,%3,null); *]
                 | LogicalOrs ':' LogicalOrs                [* %% = %1 *]
                 /~ Next ~//~
                 | LogicalOrs
                 ;
~/
Expr:              Conditional
                 ;

Conditional:       Conditional '?' CondSwap                  [* %% = new Token(OP_COND,%1,%3); *]
                 | CondSwap
                 ;

CondSwap:          ':' CondSwap                              [* %% = new Token(OP_CTOG,null,%2); *]
                 | LogicalOrs ':' CondSwap                   [* %% = new Token(OP_CTOG,%1,%3); *]
                 | LogicalOrs
                 ;

LogicalOrs:        LogicalOrs OR LogicalAnd                  [* %% = new Token(OP_OR,%1,%3); *]
                 | LogicalOrs XOR LogicalAnd                 [* %% = new Token(OP_XOR,%1,%3); *]
                 /~ Next ~/
                 | LogicalAnd
                 ;

LogicalAnd:        LogicalAnd AND BitwiseOr                  [* %% = new Token(OP_AND,%1,%3); *]
                 /~ Next ~/
                 | BitwiseOr
                 ;

BitwiseOr:         BitwiseOr '|' BitwiseXor                  [* %% = new Token(OP_BOR,%1,%3); *]
                 /~ Next ~/
                 | BitwiseXor
                 ;

BitwiseXor:        BitwiseXor '^' BitwiseAnd                 [* %% = new Token(OP_BXOR,%1,%3); *]
                 /~ Next ~/
                 | BitwiseAnd
                 ;

BitwiseAnd:        BitwiseAnd '&' Comparisons                [* %% = new Token(OP_BAND,%1,%3); *]
                 /~ Next ~/
                 | Comparisons
                 ;

Comparisons:       Comparisons EQU AddSub                    [* %% = new Token(OP_EQU,%1,%3); *]
                 | Comparisons NEQ AddSub                    [* %% = new Token(OP_NEQ,%1,%3); *]
                 | Comparisons GTR AddSub                    [* %% = new Token(OP_GTR,%1,%3); *]
                 | Comparisons GEQ AddSub                    [* %% = new Token(OP_GEQ,%1,%3); *]
                 | Comparisons LSS AddSub                    [* %% = new Token(OP_LSS,%1,%3); *]
                 | Comparisons LEQ AddSub                    [* %% = new Token(OP_LEQ,%1,%3); *]
                 | Comparisons MIN AddSub                    [* %% = new Token(OP_MIN,%1,%3); *]
                 | Comparisons MNE AddSub                    [* %% = new Token(OP_MNE,%1,%3); *]
                 | Comparisons MAX AddSub                    [* %% = new Token(OP_MAX,%1,%3); *]
                 | Comparisons XNE AddSub                    [* %% = new Token(OP_XNE,%1,%3); *]
                 | Comparisons '<<' AddSub                   [* %% = new Token(OP_SLSS,%1,%3); *]
                 | Comparisons '<=<' AddSub                  [* %% = new Token(OP_SLEQ,%1,%3); *]
                 | Comparisons '>>' AddSub                   [* %% = new Token(OP_SGTR,%1,%3); *]
                 | Comparisons '>=>' AddSub                  [* %% = new Token(OP_SGEQ,%1,%3); *]
                 /~ Next ~/
                 | AddSub
                 ;

AddSub:            AddSub '+' MulDivMod                      [* %% = new Token(OP_ADD,%1,%3); *]
                 | AddSub '-' MulDivMod                      [* %% = new Token(OP_SUB,%1,%3); *]
                 /~ Next ~/
                 | MulDivMod
                 ;

MulDivMod:         MulDivMod '*' Dice                        [* %% = new Token(OP_MUL,%1,%3); *]
                 | MulDivMod '/' Dice                        [* %% = new Token(OP_DIV,%1,%3); *]
                 | MulDivMod '%' Dice                        [* %% = new Token(OP_MOD,%1,%3); *]
                 /~ Next ~/
                 | Dice
                 ;

Dice:              Unary d Unary e '{' Expr '}'              [* %% = new Token(OP_DICE,%1,%3,%6); *]
                 | Unary d Unary                             [* %% = new Token(OP_DICE,%1,%3,null); *]
                 /~ Next ~/
                 | Unary
                 ;

Unary:             '+' Unary                                 [* %% = new Token(OP_POS,%2); *]
                 | '-' Unary                                 [* %% = new Token(OP_NEG,%2); *]
                 | NOT Unary                                 [* %% = new Token(OP_NOT,%2); *]
                 | '@' Unary                                 [* %% = new Token(OP_STR,%2); *]
                 | '#' Unary                                 [* %% = new Token(OP_NUM,%2); *]
                 /~ Next ~/
                 | Value
                 ;

Value:             Number                                    [* %% = new Token(VAL_NUM,%1); *]
                 | String '[' Expr ']'                       [* %% = new Token(OP_IDX,new Token(VAL_STR,%1),%3); *]
                 | String                                    [* %% = new Token(VAL_STR,%1); *]
                 | Variable '[' Expr ']'                     [* %% = new Token(OP_IDX,new Token(VAR,%1),%3); *]
                 | Variable                                  [* %% = new Token(VAR,%1); *]
                 | '(' Expr ')' '[' Expr ']'                 [* %% = new Token(OP_IDX,new Token(OP_PARA,%2),%5); *]
                 | '(' Expr ')'                              [* %% = new Token(OP_PARA,%2); *]
                 | Value Value                               [* %% = %2 *]
                 | Value n                                   [* %% = new Token(OP_IGNR,%1); *]
                 ;

[*
function processCode(code,printHandler,errorHandler){
	var errCount, errOffsets = [], errExpects = [];
	vars = {
		m: [], x: [], a: [], r: [],
		M: [], X: [], A: [], R: [],
		o: 0, c: 0, z: [], y: 0, s: 0, i: 0,
	}
	curOptions = "PRGdUMSCBAOTiVLN";
	rollIdx = 0;
	exprs = [];
	prolls = [];
	code = code.replace(/(([^'"e]*|'[^']*'|"[^"]*")*e *\{)/g,"$1o ");
	if((errCount = __##PREFIX##parse(code, errOffsets, errExpects)) > 0){
		var moreThanOneLine = code.split("\n").length > 1;
		for(var i=0;i<errCount;++i){
			var tcode = code.slice(0,errOffsets[i]+5).replace(/(([^'"e]*|'[^']*'|"[^"]*")*e *\{)o /g,"$1")
			, spl = tcode.slice(0,-5).split("\n")
			, line = spl.length
			, col = spl[line-1].length;
			errorHandler(i, line, col, errExpects[i], tcode.slice(-8), moreThanOneLine);
		}
		return false;
	}
	
	function nrJoin(arr,x,rep){ //No Repeats
		var last = null, ret;
		for(var i=0;i<arr.length;++i){
			if(arr[i] === last)ret += rep
			else if(i) ret += x+arr[i];
			else ret = String(arr[i]);
			last = arr;
		}
		return ret;
	}
	
	for(var i=0;i<prolls.length;++i){
		var pri = prolls[i]
		, is1 = (pri.length == 1);
		for(var j=0;j<pri.length;++j){
			var pr;
			pr = (limited ? nrJoin(pri[j],", ",".") : pri[j].join(", "))+" ]";
			if(!pri[j].totals){
				pr += " = "+pri[j].total;
			}
			printHandler("Set "+(i+1)+(is1?"":"."+(j+1))+": [ "+pr);
		}
	}
	for(i=0;i<exprs.length;++i){
		printHandler(exprs[i]);
	}
	return true;
}

if(typeof(prompt) != "undefined"){
	processCode(prompt("Enter code:"),function (idx, offset, expects){
		alert("ERROR("+idx+"): At character "+offset+". Expecting:\n  "+expects.join("  "));
	});
}else if(require("path").basename(process.argv[1]).slice(0,5) == "dice."){
	//Command Line
	var code;
	limited = false;
	if(process.argv[2] == "-e"){
		//Execute arguments
		code = process.argv.slice(3).join(" ")
	} else {
		//Load from file
		code = require("fs").readFileSync(process.argv[2],"utf8");
	}
	var time = Date.now();
	processCode(code,console.log,function (idx, line, col, expects, bit, mtol){
		if(mtol){
			console.log("ERROR("+idx+"): At line "+line+" offset "+col+". Near:\n"
			+"  "+bit+"\nExpecting:\n  "+expects.join("  "));
		} else {
			console.log("ERROR("+idx+"): At character "+col+". Near:\n"
			+"  "+bit+"\nExpecting:\n  "+expects.join("  "));
		}
	});
	console.log("Execution took "+(Date.now()-time)+" milliseconds.");
} else {
	//Module
	limited = true;
}
*]
