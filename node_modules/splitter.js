var
	Class = require("class")
	,exception = require("exception")
	,comp = require("comp")
;

/** EXCEPTIONS **/
function AssertionFailed(expected,got,position){exception(this)}
function ParserError(message,position,data){exception(this)}
function UnmatchedBracket(brackets,position){exception(this)}

/** Shorthand Funcs **/
function limSplit(str,spl,lim,returnDelims){
	//Unlike default limited split because it retains the trailing pieces
	if(typeof(returnDelims) == "undefined")returnDelims=false;
	if(!Array.isArray(spl))spl = [spl];
	var find = new RegExp("["+escapeRE4Set(spl.join(""))+"]"),ret=[],m;
	for(var i=0;(m=str.match(find)) && i < lim;++i){
		ret.push(str.substr(0,m.index));
		if(returnDelims)ret.push(m[0]);
		str = str.substr(m.index+m[0].length);
	}
	if(str)ret.push(str);
	return ret;
	/*
	var arr = str.split(spl);
	if(arr.length <= lim+1)return arr;
	return arr.slice(0,lim).concat(arr.slice(lim).join(spl));
	*/
}

/**
* Escape for RegEx functions
**/
function escapeRE4Set(set,allDash){
	var tmp = /--/g; //-- is literal -, - is range
	if(1 in arguments)tmp = /-/g; //Escape all -
	return set
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]])/g,"\\$1")
		.replace(tmp,"\\-")
	;
}

function escapeRE(str){
	return str
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]{}()^$+*.?|])/g,"\\$1")
	;
}

/** HELPER FUNCTIONS **/
function applySplitter_findEnd(spltr,i,find){
	var end=i,mod="",xtra=0,str,pre="",c;
	//Find the ending bracket (next unescaped bracket)
	while((end=spltr.indexOf(find,end+1)) >= 0
	&& spltr.charAt(end-1) == "%");
	
	//None was found
	if(end == -1) throw new UnmatchedBracket(spltr.charAt(i)+find,i);
	
	//Check for modifiers
	/*switch(spltr.charAt(end+1)) //For if more than one are added*/

	while((c = spltr.charAt(end+1+xtra))
	&& mod.indexOf(c) == -1
	&& (c == "*" || c == "?")){
		mod += c; ++xtra;
	}
	
	//Split out prepender
	str = spltr.slice(i+1,end);
	if(str.charAt(1) == "|" && str.charAt(0) != "%"){
		pre = str.charAt(0);
		str = str.slice(2);
	}
	
	//Return contents without %s or brackets
	return [str.replace(/%(.)/g,"$1"),mod,end+xtra,pre];
}

function fashionTokenRE(token,subGroups){
	var theGrp = token[0],ctoken,theOptions,mod,subGrp
	,pre,tore,re="",grpIdx = 1,sgi=0,groups={};
	for(var ch=0;ch<theGrp.length;++ch){
		if(ch%2 == 0){
			re += escapeRE(theGrp[ch]);
		} else {
			theOptions = theGrp[ch];
			var optsExist=(theOptions.length!=1),tmpre = "";
			if(optsExist){
				tmpre = "(";
				++grpIdx;
			}
			for(var ori=0;ori<theOptions.length;++ori){
				ctoken = theOptions[ori];
				tore = ctoken[1];
				mod = ctoken[2];
				pre = ctoken[4];
				if(mod.indexOf("*") != -1)tore = "("+tore+"("+pre+tore+")*)";
				else tore = "("+tore+")";
				if(mod.indexOf("?") != -1)tore += "?";
				//Merge subGroups info into groups
				if(Array.isArray(ctoken[0])){
					if(mod.indexOf("*") != -1){
						groups[grpIdx] = subGroups[sgi++];
						groups[grpIdx].token = ctoken;
					} else {
						subGrp = subGroups[sgi++];
						for(var i in subGrp){
							groups[grpIdx+parseInt(i)] = subGrp[i];
						}
					}
				} else {
					groups[grpIdx] = ctoken;
				}
				//Number of unescaped ( in tore
				grpIdx += ((" "+tore).match(/[^\\](?=\()/g) || []).length;
				tmpre += tore+"|";
			}
			re += tmpre.slice(0,-1);
			if(optsExist)re += ")";
		}
	}
	
	token[1] = re;
	return groups;
}

module.exports = Class({
	//Split expression and store comprehension
	//XXX(Posibility): Compile comprehension into a function to form things
	name: "Splitter",
	//TODO: Add case insensitivity argument
	init: function(spl,globalRefs,caseInsensitive){
		this.source = spl;
		this.tokens = [""];
		this.regex = /$^/;
		this.groups = {};
		
		if(typeof(globalRefs) == "undefined")globalRefs = {};
		if(typeof(caseInsensitive) == "undefined")caseInsensitive = false;
		
		var len = spl.length,tidx=0,re="",nom,tore,mod,ni,pre
		,lastWasGrp=false,current=this.tokens,parents=[],wasgrp,orArray=null
		,subGroups=[[]],namespace=[],nsLimit=[],curNS=-1;
		for(i=0;i<len;++i){
			c = spl.charAt(i);
			nom = null; tore = ""; ni = i; wasgrp = false;
			switch(c){
				case "<": { //Spaceless group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,">");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					if(grp.charAt(0) == "#"){
						//Number form
						var num = grp.slice(1).split(":");
						nom = num[0];
						if(num.length == 1)tore = "[0-9]+";
						else switch(num[1]){
							case ".": tore = "[0-9]+(\.[0-9]+)?"; break;
							case ".s": tore = "[0-9.]+"; break;
							case ",": tore = "[0-9,]+"; break;
							case ",s": tore = "[0-9]+(,[0-9]+)?"; break;
							case ".,": case ",.": tore = "[0-9,]+(\.[0-9]+)?"; break;
							case ".,s": case ",.s": tore = "[0-9.]+(,[0-9]+)?"; break;
							default: throw new AssertionFailed("/[.,]{1,2}s?/",num[1],i);
						}
					} else {
						//Regular form
						var pt = limSplit(grp,[":","=","!","@"],1,true);
						nom = pt[0];
						if(pt.length == 1){
							tore = "[^ "+pre+"]+";
						} else switch(pt[1]){
							case ":": {
								//These are not allowed as well as space
								tore = "[^ "+pre+escapeRE4Set(pt[2])+"]+";
								break;
							} case "=": {
								//Only these are allowed
								if(pt[2].slice(-1) == "+"){
									tore = "["+escapeRE4Set(pt[2]).slice(0,-1)+"]+";
								} else {
									tore = "["+escapeRE4Set(pt[2])+"]";
								}
								break;
							} case "!": {
								//Only these and the separator are not allowed
								tore = "[^"+(pre?pre:" ");
								if(pt[2].slice(-1) == "+"){
									tore += escapeRE4Set(pt[2]).slice(0,-1)+"]+";
								} else {
									tore += escapeRE4Set(pt[2])+"]";
								}
								break;
							} case "@": {
								//Reference
								if(pt[2].charAt(0) == "_"){
									if(!(pt[2] in globalRefs)){
										throw new AssertionFailed(
											pt[2]+" in global definitions","Not found",i
										);
									}
									var struct = globalRefs[pt[2]],stFirst = struct.charAt(0)
									, matches = {"<":">","{":"}","/":"/"},grp2;
									//TODO: Make this check if there's only one top level group too.
									if(stFirst in matches && applySplitter_findEnd(
										struct,0,matches[stFirst])[2] == struct.length-1
									){
										//If there's only one token in the global ref,
										// apply mod and pre directly to that
										if(pre)struct = stFirst+pre+"|"+struct.slice(1);
										if(mod)struct += mod;
									} else {
										//Otherwise surround it with a group
										if(mod && pre)struct = "("+pre+"|"+struct+")"+mod;
										else if(mod)struct = "("+struct+")"+mod;
										else if(pre)struct = "("+pre+"|"+struct+")";
									}
									if(nom){
										namespace.push(nom);
										nsLimit.push(i+struct.length);
										++curNS;
									}
									spl = spl.slice(0,i)+struct+spl.slice(ni+1);
									len = spl.length;
									ni = i-1;
									nom = null;
								} else {
									for(var x in this.groups){
										if(this.groups[x][0] == pt[2]){
											tore = this.groups[x][1];
											if(mod=="")mod = this.groups[x][2];
											if(pre=="")pre = this.groups[x][4];
											break;
										}
									}
									if(tore == ""){
										throw new AssertionFailed(
											pt[2]+" to be defined","Was not defined",i
										);
									}
								}
								break;
							}
						}
						if(pre=="")pre = " ";
					}
					break;
				} case "{": { //Spaced group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,"}"),tm;
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					//Limited spaces versions
					if(tm = grp.match(/([^:=]+)([:=])([0-9]+)/)){
						nom = tm[1];
						if(pre=="")pre = " ";
						switch(tm[2]){
							case ":": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){0,"+tm[3]+"}"; break;
							case "=": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){"+tm[3]+"}"; break;
						}
					} else if(grp.search(/[:=]/) >= 0) {
						throw new AssertionFailed("Number for argument",
							grp.slice(grp.search(/[:=]/)+1),i
						);
					} else {
						nom = grp;
						if(pre != "")tore = "[^"+pre+"]+";
						else tore = ".+"
					}
					break;
				} case "/": { //Specific group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,"/");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]||" "; grp=grp[0];
					var pt = limSplit(grp,":",1);
					if(pt.length != 2){
						throw new AssertionFailed(
							"This form requires an argument","No argument",i
						);
					}
					nom = pt[0];
					tore = pt[1];
					break;
				} case "(": { //Group
					lastWasGrp = false;
					wasgrp = true; mod = "";
					break;
				} case "[": { //Optional group
					lastWasGrp = false;
					wasgrp = true; mod = "?";
					break;
				} case ")": { //Group end
					//fall through
				} case "]": { //Optional group end
					lastWasGrp = true;
					current = parents.pop();
					tidx = current.length-1;
					//Fix mod if there's a * next
					var thatGrp=current[tidx-1].slice(-1)[0];
					if(spl.charAt(i+1) == "*"){
						ni = ++i;
						thatGrp[2] += "*";
					}
					//Combobulate tore
					subGroups[parents.length].push(fashionTokenRE(thatGrp,
						subGroups[parents.length+1]
					));
					break;
				} case "%": { //Literal
					lastWasGrp = false;
					c = spl.charAt(ni=++i);
					//fall through
				} case "|": { //Multiple options if between groups
					if(lastWasGrp){
						lastWasGrp = false;
						orArray = current[tidx-1];
						break;
					}
					//fall through
				} default: {
					if(orArray)throw new AssertionFailed(
						"Or operator requires a group directly after it.","No group",i
					);
					lastWasGrp = false;
					current[tidx] += c; 
					//re += escapeRE(c);
					break;
				}
			}
			if(wasgrp){
				//Find pre
				if(spl.charAt(i+2) == "|"){
					pre = spl.charAt(i+1);
					ni = i+2;
				} else {
					pre = " ";
				}
				//Check namespace
				var group = [""]
				,token = [group,"",mod,i,pre,namespace.join(".")];
				if(orArray){
					orArray.push(token)
					orArray = null;
				} else {
					current.push([token]);
					current.push("");
				}
				if(subGroups.length-1 <= parents.length){
					subGroups.push([]);
				}
				parents.push(current);
				current = group;
				tidx = 0;
			}
			else if(nom != null){
				var token = [nom,tore,mod,i,pre,namespace.join(".")];
				if(orArray){
					orArray.push(token);
					orArray = null;
				} else {
					current.push([token]);
					current.push("");
				}
				tidx += 2;
				//re += tore;
			}
			if(wasgrp || nom != null){
				ns="";
				if(curNS != -1){
					while(ni >= nsLimit[curNS]-1){
						namespace.pop();
						nsLimit.pop();
						--curNS;
					}
				}
			}
			i = ni;
		}
		if(parents.length){
			console.log(spl);
			throw new UnmatchedBracket(
				"[]()",i
			);
		}
		var tmpToken = [this.tokens,"","",0," "];
		this.groups = fashionTokenRE(tmpToken,subGroups[0]);
		//console.log(tmpToken[1]);
		this.regex = new RegExp("^"+tmpToken[1]+"$",caseInsensitive?"i":"");
		if(spl != this.source)this.finalSource = spl;
	},
	
	//TODO: Calculate additional per level rather than at the base level
	_matches: function(data,tokens,haso){
		var missing=0,numIdx=0,i,j,k;
		for(i=1;i<tokens.length;i+=2){
			var opts = tokens[i],optional=0;
			for(j=0;j<opts.length;++j){
				nn=opts[j][0],mod=opts[j][2];
				if(Array.isArray(nn)){
					if(mod.indexOf("*") != -1){
						haso[numIdx] = 1; //NOTE: Just a bandaid... ^
						var dni=(numIdx in data)?data[numIdx++]:[];
						for(k=0;k<dni.length;++k){
							if(this._matches(dni[k],nn,haso) < 0){
								++missing;
								break;
							}
						}
						if(k == 0){if(mod.indexOf("?") != -1)++optional;}
						else break;
					} else {
						if(this._matches(data,nn,haso) < 0){
							if(mod.indexOf("?") != -1) {
								++optional;
							}
						} else {
							break;
						}
					}
				}
				else if(nn in data){
					haso[nn] = 1;
					break;
				}
			}
			if(j == opts.length && optional != j)++missing;
		}
		return -missing;
	},
	matches: function(x){
		if(typeof(x) == "string")return !!x.match(this.regex)
		else{
			//Check content of x (object) against the tokens
			//+list (this.tokens[i%2][0]).
			//Return: 0 for exact match, positive for more than needed,
			//+negative for less than needed. If there is both more and
			//+less, less is returned.
			var haso={},added=0
			,missing = this._matches(x,this.tokens,haso);
			for(var y in x){
				if(!(y in haso))added++;
			}
			return (missing?missing:added);
		}
	},
	
	_read: function(m,groups,ret){
		//console.log("_read");
		var numIdx = 0;
		for(var i=1;i<m.length;i++){
			var res=m[i],pushTo,nom;
			//Is this existant?
			if(i in groups && res){
				if("token" in groups[i]){
					var arr = [],tmp,tk=groups[i].token,tkLen;
					nom = numIdx++;
					var re = new RegExp("^("+tk[1]+")("+tk[4]+tk[1]+")*$");
					while((tmp = res.match(re)) && tmp[0].length){
						tkLen = tmp[1].length;
						tmp.splice(1,1); tmp.splice(-1,1);
						arr.push(this._read(tmp,groups[i],{}));
						res = res.slice(tkLen+tk[4].length);
					}
					res = arr;
					pushTo = ret;
				} else {
					//console.log(i+" in groups.");
					var mod = groups[i][2]
					,   re  = groups[i][1]
					,   pos = groups[i][3]
					,   pre = groups[i][4]
					,   ns  = groups[i][5]
					;///var
					nom = groups[i][0];
					pushTo = ret;
					if(mod.indexOf("*") != -1) {
						var arr = [],tmp;
						re = new RegExp("^("+re+")("+pre+re+")*$");
						while((tmp = res.match(re)) && tmp[0].length){
							arr.push(tmp[1]);
							res = res.slice(tmp[1].length+pre.length);
						}
						res = arr;
					}
					if(ns){
						var nss = ns.split(".");
						for(var j=0;j<nss.length;++j){
							if(!(nss[j] in pushTo))pushTo[nss[j]] = {};
							pushTo = pushTo[nss[j]];
						}
					}
				}
				//console.log(nom+":"+res);
				if(typeof(res) != "undefined"){
					if(nom in pushTo && !comp(pushTo[nom],res)){
						throw new AssertionFailed(pushTo[nom],res,pos);
					}
					pushTo[nom] = res;
				}
			}
		}
		return ret;
	},
	read: function(msg){
		var m = msg.match(this.regex),ret={};
		if(!m)return null;
		//console.log("Matched ok");
		return this._read(m,this.groups,ret);
	},
	
	_write: function(data,except,tokens){
		var ret = "",i,j,k,numIdx=0;
		for(i=0;i<tokens.length;++i){
			//Literal
			if(i%2 == 0){
				//console.log("Writing: '"+tokens[i]+"'");
				ret += tokens[i];
			} else {
				//Group
				var opts = tokens[i],optional=0;
				//console.log("Enumerating "+opts.length+" options.");
				for(j=0;j<opts.length;++j){
					var tk = opts[j];
					var ns = data;
					if(tk[5]){
						var nss = tk[5].split(".");
						for(var k=0;k<nss.length;++k){
							if(!(nss[k] in ns)){
								throw new AssertionFailed(
									nss.slice(0,k).join(".")+" namespace","Nothing",tk[3]
								);
							}
							ns = ns[nss[k]];
						}
					}
					if(Array.isArray(tk[0])){
						//() or []
						//console.log("Was group.");
						if(tk[2].indexOf("*") != -1){
							var tmp,dni=(numIdx in ns)?ns[numIdx++]:[];
							for(k=0;k<dni.length;++k){
								if(!(tmp = this._write(dni[k],except,tk[0]))){
									throw new ParserError("Validation failed in a group list.",tk[3],dni[k]);
								}
								if(k>0)ret += tk[4];
								ret += tmp;
							}
							if(k == 0){if(tk[2].indexOf("?") != -1)++optional;}
							else break;
						} else {
							var tmp = this._write(data,except,tk[0]);
							if(tmp){
								ret += tmp;
								break;
							} else if(tk[2].indexOf("?") != -1) {
								++optional;
							}
						}
					} else {
						//Other group
						//console.log("Was token: "+tk[0]);
						if(tk[0] in except)break;
						//console.log(tk[0]+" in",ns);
						if(tk[0] in ns){
							//console.log("Exists in data");
							var d = ns[tk[0]];
							if(typeof(d) == "string")d = [d];
							for(k=0;k<d.length;++k){
								if(!d[k].match("^("+tk[1]+")$")){
									throw new AssertionFailed(tk[1],d[k],tk[3]);
								}
							}
							if(tk[2].indexOf("*") != -1)d = d.join(tk[4]);
							else d = d[0];
							//console.log("Final data looks like: '"+d+"'");
							ret += d;
							break;
						} else if(tk[2].indexOf("?") != -1) {
							++optional;
						}
					}
				}
				if(j == opts.length && optional != j)return "";
			}
		}
		return ret;
	},
	
	write: function(data,except){
		var tmp={};
		if(Array.isArray(except)){
			for(var i=0;i<except.length;++i){
				tmp[except[i]] = true;
			}
		} else if(typeof(except) == "string") {
			tmp[except] = true;
		}
		return this._write(data,tmp,this.tokens);
	},
})
