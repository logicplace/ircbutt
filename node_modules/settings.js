var
	fs = require("fs")
	, jslon = require("jslon")
;

function getParentProp(x){
	var tmp = this;
	while("_parent" in tmp && !(x in tmp._parent)){
		tmp = tmp._parent;
	}
	if("_parent" in tmp)return this._parent[x];
	else return undefined;
}
function _getParentProp(x){
	return function(){ return getParentProp.call(this,x); };
}

function setSelf(x,y){
	if(x in this)delete this[x];
	this[x] = y;
}
function _setSelf(x){
	return function(y){ return setSelf.call(this,x,y); };
}

// Do a normalization check for a context field that can only be one type or in
// a set of values. If typeOrValues is a string, it does a type check.
// Otherwise, it checks to see if the value is in an array of values.
// If typeOrValues is a regex it will match it against the value, assuming it's
// a stirng.
function normalizeValue(context,def,field,typeOrValues,defValue){
	var val;
	if(typeof(typeOrValues) == "undefined"){
		val = context;
		typeOrValues = field;
		field = def;
		def = false;
	} else if (field in context){
		val = context[field];
	} else if(def) {
		context[field] = defValue;
		return;
	} else {
		throw new TypeError(
			"Form is normalizeValue(context,def,field,typeOrValues[,defValue])"
			+" or normalizeValue(val,name,typeOrValues)"
		);
	}
	
	if(typeof(typeOrValues) == "string"){
		if(typeof(val) != typeOrValues){
			throw new TypeError(field + " must be a " + typeOrValues);
		}
	} else if(Array.isArray(typeOrValues)){
		for(var i = 0; i < typeOrValues.length; i++){
			if (typeOrValues[i] === val){
				return;
			}
		}
		// TODO: not really a type error
		throw new TypeError(field + " is not in set: " + typeOrValues);
	} else if(typeOrValues.constructor.name == "RegExp") {
		if(typeof(val) != "string") {
			throw new TypeError(field + " must be a string");
		}
		if(!typeOrValues.match(val)){
			// TODO: not really a type error
			throw new TypeError(field + " does not match " + typeOrValues);
		}
	} else {
		throw new TypeError("typeOrValues must be string, array, or regex");
	}
}

//Normalizes settings so that access method is consistent
function normalize(context,def){
	var i,len,x,tmp;
	/** HOST **
	* Network to connect to
	* Port is optional, defaults to 6667
	* Accepts string, array
	**/
	if("host" in context){
		context.port = [];
		//Make strings into an array usable below
		if(typeof(context.host) == "string"){
			context.host = [context.host];
		}
		//Enumerate possible addresses array
		if(Array.isArray(context.host)){
			len = context.host.length;
			for(i=0;i<len;++i){
				x = context.host[i];
				if(typeof(x) == "string"){
					tmp = (context.host+":6667").split(":",2);
					context.host[i] = tmp[0]==""?null:tmp[0];
					context.port[i] = tmp[1];
				} else {
					throw new TypeError("host array must only contain strings");
				}
			}
		} else {
			throw new TypeError("host must be string or array");
		}
	} else if(def)context.host = undefined;

	/** CHANNEL **
	* Channel(s) to connect to
	* Accepts string, array
	**/
	if("channel" in context){
		if(typeof(context.channel) == "string"){
			context.channel = [context.channel];
		} else if(!Array.isArray(context.channel)){
			throw new TypeError("channel must be string or array");
		}
	} else if(def)context.channel = undefined;

	/** NICK **
	* Nickname(s) to use
	* Accepts string, array
	* If all nicks are taken and nothing can be done about it, fail connection
	**/
	if("nick" in context){
		if(typeof(context.nick) == "string"){
			context.nick = [context.nick];
		}
		tmp = context.nick;
		len = tmp.length;
		for(i=0;i<len;++i){
			if(typeof(tmp[i]) == "string"){
				tmp[i] = [tmp[i],null];
			} else if(Array.isArray(tmp[i])){
				if(tmp[i].length > 2)tmp[i].length = 2;
				else if(tmp[i].length == 1)tmp[i].push(null);
				else if(tmp[i].length == 0)tmp[i].extend = [undefined,null];
			} else if(tmp[i].constructor.name == "Object"){
				for(x in tmp[i]){
					tmp[i] = [x,tmp[i][x]];
					break;
				}
			}
		}
	} else if(def)context.nick = "IRCButt";

	/** USER **
	* Username to register as
	* If ident is enabled, it will fall back to this for the username
	* Accepts string
	*** USERMODE **
	* http://tools.ietf.org/html/rfc2812#section-3.1.5
	* Accepts string, number
	*** REAL **
	* Real name
	* Accepts string
	**/
	// TODO: no normalizeValue calls set defaults right now
	normalizeValue(context,def,"user","string","ircbutt");
	if("usermod" in context){
		// TODO: fill in
		if(typeof(context.usermod) == "string"){
		} else if(typeof(context.usermod) == "number"){
		} else {
			throw new TypeError("usermod must be a string or number");
		}
	} else if(def); // TODO

	normalizeValue(context,def,"real","string","IRCButt");
	/** PASS **
	* Connection pass
	* Does not send a pass if omitted or blank
	* Accepts string
	**/
	normalizeValue(context,def,"pass","string");

	if("passwords" in context){
		if(typeof(context.passwords) == "string"){
			context.passwords = [context.passwords];
		} else if(Array.isArray(context.passwords)){
			tmp = context.passwords;
			len = tmp.length;
			for(i=0;i<len;++i){
				if(typeof(tmp[i]) != "string"){
					throw new TypeError("passwords array must contain strings");
				}
			}
		} else {
			throw new TypeError("passwords must be string or array of strings");
		}
	} else if(def) context.passwords = [];
	normalizeValue(context,def,"remotePass","string");

	if("remoteWeb" in context) {
		tmp = context.remoteWeb;
		for(var user in tmp){
			if(tmp.hasOwnProperty(user)){
				if(typeof(tmp[user]) != "string"){
					throw new TypeError("remoteWeb passwords must be strings");
				}
			}
		}
	} else if(def) context.remoteWeb = {};
	
	//TODO: Check if spec exists? Or should that error elsewhere?
	if("spec" in context) {
		if(typeof(context.spec) == "string"){
			context.spec = [context.spec];
		} else if(Array.isArray(context.spec)){
			tmp = context.spec;
			len = tmp.length;
			for(i=0;i<len;++i){
				if(typeof(tmp[i]) != "string"){
					throw new TypeError("spec array must contain strings");
				}
			}
		} else {
			throw new TypeError("spec must be string or array of strings");
		}
	} else if(def) context.spec = ["other","rfc2","rfc1"];
	normalizeValue(context,def,"hostIdent","boolean",false);
	normalizeValue(context,def,"prefix",/[^a-zA-Z0-9]/,"!");
	normalizeValue(context,def,"logAll","boolean",false);
	normalizeValue(context,def,"logCommands","boolean",false);
	normalizeValue(context,def,"logConvo","boolean",false);
	normalizeValue(context,def,"logErrors","boolean",true);
	normalizeValue(context,def,"logAuth","boolean",true);
	normalizeValue(context,def,"logDebug","boolean",false);
	
	/** Arbitrary commands to send **/
	if("commands" in context){
		tmp = context.commands;
		if(Array.isArray(tmp) && tmp.length == 2){
			for(i=0;i<2;++i){
				if(typeof(tmp[i]) == "string" || tmp[i].constructor.name == "Object"){
					tmp[i] == [tmp[i]];
				}
				for(var j=0;j<tmp[i].length;++j){
					if(tmp[i].constructor.name == "Object"){
						//NOTE: Properly, {command: x, args:{...}} but args is optional.
						if(!("command" in tmp[i])){
							throw new TypeError("commands objects must contain a command field");
						}
					} else if(typeof(tmp[i]) != "string"){
						throw new TypeError("commands arrays must contain strings or objects");
					}
				}
			}
		} else {
			throw new TypeError("commands must be an array containing two entries");
		}
	} else if(def) context.commands = [[],[]];
	
	/** Flood control options **/
	if("flood" in context){
		tmp = context.flood;
		if(tmp.constructor.name == "Object"){
			normalizeValue(tmp,def,"amount","number",5);
			var defval = {wait:[0,2000],chars:[512,256]};
			for(x in {wait:1,chars:1}){
				if(x in tmp){
					if(typeof(tmp[x]) == "number")tmp[x] = [tmp[x],tmp[x]];
					else if(Array.isArray(tmp[x])){
						normalizeValue(tmp[x],def,0,"number",defval[x][0]);
						normalizeValue(tmp[x],def,1,"number",defval[x][1]);
						tmp[x].length = 2;
					} else {
						throw new TypeError("flood."+x+" must be a number or array of two numbers");
					}
				} else if(def)tmp[x] = defval[x];
			}
		} else {
			throw new TypeError("flood must be an object");
		}
	} else if(def) context.flood = {amount:5,wait:[0,2000],chars:[512,256]};
	
	//Ask a database for user information instead
	if("remoteUserDB" in context){
		if(Array.isArray(context.remoteUserDB)){
			if(typeof(context.remoteUserDB[0]) != "string"){
				throw new TypeError("remoteUserDB[0] must be a string");
			}
		} else {
			throw new TypeError("remoteUserDB must be an array");
		}
	} else if(def)context.remoteUserDB = undefined;
	
	//TODO: Validate the existence of the given auth module?
	normalizeValue(context,def,"authMethod","string",undefined);
	
	if("modules" in context){
		tmp = context.modules;
		if(tmp.constructor.name == "Object"){
			for(x in tmp){
				if(tmp[x].constructor.name == "Object"){
					if(!("path" in tmp[x])){
						throw new TypeError("modules."+x+" must contain a path key");
					}
				} else {
					throw new TypeError("modules."+x+" must be an object");
				}
			}
		} else {
			throw new TypeError("modules must be an object");
		}
	} else if(def)context.modules = {}
}

function bubblesTo(obj,key){
	//NOTE: This could throw an exception if you don't pass a settings object
	// I don't care about you if you're that stupid
	while(key in obj && obj.__lookupGetter__(key)){
		obj = obj._parent;
	}
	return obj;
}

function loadFile(file,callback){
	fs.readFile(file,function(err,data){
		if(err)throw err;
		var root = jslon.parse(data);
		//Lowest children are most important
		//Trace heirarchy backwards to bubble up
		var lowest = [];
		function recurse(x,nom){
			x._name = nom;
			if("$" in x){
				x.$._parent = x;
				for(var i in x.$){
					var child = x.$[i];
					for(var j in x){
						//Add a bubbler for attributes the parent has
						// but the child doesn't
						if(j.charAt(0) != "_" && !(j in child)){
							child.__defineGetter__(j,_getParentProp(j));
							child.__defineSetter__(j,_setSelf(j));
						}
					}
					recurse(child,i);
				}
			} else {
				lowest.push(x);
			}
		}
		recurse(root,"root");
		callback(root,lowest);
	});
}

function load(){
	//TODO: Load from database
}

//TODO: Save functions

function comp(a,b){
	var type;
	if((type=a[x].constructor.name) != b[x].constructor.name)return false;
	switch(type){
		case "Array":  return compArr(a[x],b[x]);
		case "Object": return compObj(a[x],b[x],true);
		default:       return a[x] != b[x];
	}
}

function compArr(a,b){
	for(var i=0;i<a.length;++i){
		for(var j=0;j<b.length;++j){
			if(comp(a[i],b[j]))break;
		}
		if(j == b.length)return false;
	}
	return true;
}

function compObj(a,b,noCheckGetter){
	for(var x in a){
		if(x in b && (noCheckGetter || !b.__lookupGetter__(x))){
			if(!comp(a[x],b[x]))return false;
		} else return false
	}
	return true;
}

function lookup(settings,query,normalized){
	if(!(2 in arguments) || !normalized)normalize(query,false);
	var ret = [];
	if(compObj(query,settings,false))ret.push(settings);
	if("$" in settings)ret.concat(lookup(settings.$,query,true));
	return ret;
}

module.exports = {
	bubblesTo: bubblesTo,
	loadFile: loadFile,
	lookup: lookup,
}
