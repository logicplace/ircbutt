//This should handle module related things, making the IRC connection; starting
//email, ident, and http daemons; and interconnecting everything.
var
	Class = require("class"),
	settings = require("./settings.js"),
	irc = require("irc")
;

//TODO: Change irc handler to have more generic events (maybe just one registered callback)
//Move advanced eventing over here to make it standard between each system.

/*
function dispatchEvents(sock,events,base,context);
 - Loops through given events and dispatches them in prioritized order.
 - sock = Socket that triggered the event
 - events = Array of five arrays signifying priority, each containing sets of [module,handler]
 - - module = Registering module's name
 - - handler = Function to call, should accept function(data[,sender[,command]])
 - base = Object containing {command:""[,args:""][,sender:""]}
 - context = Settings context
*/
function dispatchEvents(base,events,context){
	//Five priority brackets
	for(var p=0;p<5;++p){
		var ep = events[p];
		for(var i=0;i<ep.length;++i){
			var modname = ep[i][0], handler = ep[i][1], userdata = ep[i][2];
			if(context.knowledge.enabled[modname]){
				//NOTE: If a module changes this it changes it
				//+for subsequent modules. Is this bad?
				handler(base,userdata);
			}
		}
	}
}

function lower(x){return String(x).toLowerCase();}
function unorderedUncasedArray(a){
	return a.map(lower).sort();
}

function arrayMatch(a1,a2){
	var len;
	if((len=a1.length) != a2.length)return false;
	for(var i=0;i<len;++i){
		if(a1[i] !== a2[i])return false;
	}
	return true;
}

//Handles modules mostly
module.exports = Class({
	init: function(settingsFile){
		this.basePath = path.dirname(process.argv[1]);
		this.irc_events = {};
		settings.loadFile(settingsFile,function(settingsData,lowest){
			this.settings = settingsData;
			//Loop through settings...
			this.irc = [], tmp = [];
			for(var i=0;i<lowest.length;++i){
				tmp.push([
					unorderedUncasedArray(lowest[i].host),
					unorderedUncasedArray(lowest[i].nick),
					[lowest[i]],
				]);
			}
			
			//Reduce to server/nick uniqueness...
			for(i=1;i<tmp.length;){
				if(arrayMatch(tmp[i-1][0],tmp[1][0])
				&& arrayMatch(tmp[i-1][1],tmp[1][1])){
					tmp[i-1][2].push(tmp[i][2]);
					delete tmp[i];
				} else ++i;
			}
			
			//Init IRC instances
			for(i=0;i<tmp.length;++i){
				var tmpIRC = new irc();
				tmpIRC.contexts = tmp[2];
				this.irc.push(tmpIRC);
			}
			
			this._setup("irc.on"); //TODO: Redo in relation to multiple IRCs
			//TODO: email
			//TODO: http
			//TODO: ident
			
			//TODO: load modules (via function!)
		});
	},
	
	_setup: function(x){
		var l = x.split("."), ifunc = this[l.join("_")]
		, p = l[0], m = [1];
		if(m in this[p])ifunc.old = this[p][m];
		this[p][m] = ifunc;
	},
	
	connect: function(){
		//TODO: Perform all connection based on settings
	},
	
	//======= IRC FUNCTIONS =======//
	irc_on: function(modname, event, userdata, priority, handler){
		//Accepts: irc_on(modname, event[, userdata][, priority], handler);
		switch(arguments.length){
			case 3: {
				handler = userdata; priority = 2;
				userdata = null;
				break;
			} case 4: {
				handler = priority; 
				if(typeof(userdata) == "number"){
					priority = userdata;
					userdata = null;
				} else {
					priority = 2;
				}
				break;
			}
		}
		var modName = this.caller.name;		
		//If this is the first event of its type, register in the irc module: this.irc_on.old
		if(!(event in this.events)){
			this.irc_events[event] = [[],[],[],[],[]];
			this.irc.on.old(event,this.irc_event);
		} 
		//Register internally here with the priority and handler
		this.irc_events[event][priority].push([modname,handler,userdata]);
	},
	
	irc_event: function(event,data){
		//Pre-make arguments to pass to handler
		if(!("args" in data))data.args = {};
		if(!("sender" in data))data.sender = "";
		data._event = event;
		
		//TODO: Lookup context based on event's origin (server/channel/nick)
		dispatchEvents(data,this.irc_events,this.settings);
	},
});
