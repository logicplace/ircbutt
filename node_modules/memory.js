var _ = require("lodash"), packets = require("packets");

module.exports = function Memory(settings) {
	var self = this;

	// Install packets into memory
	var installedPackets = [], installedSpecs = {}, defaultPacket = {
		"numeric": null,
		"fullname": null,
		"version": 1,
		"custom": false,
		"language": "*",
		"c2s": null,
		"s2c": null,
		"s2s": null,
		"c2c": null,
	};
	this.installPackets = function installPackets(list, header) {
		// See base_protocol.json for spec
		if ("matrix" in list) {
			for (var x in list.matrix) {
				var p = packets.compilePacket(list.matrix[x]);
				p.id = x;
				p.syntax = list.matrix[x];
				p.context = "matrix";
				installedPackets.push(_(p).defaults(defaultPacket).value());
			}
		}

		if ("type" in list) {
			for (var x in list.type) {
				var p = packets.compilePacket(list.type[x]);
				p.id = x;
				p.syntax = list.type[x];
				p.context = "type";
				installedPackets.push(_(p).defaults(defaultPacket).value());
			}
		}

		if ("msg" in list) {
			for (x in list.msg) {
				var p = {}, designation = x.split("-"), di = 0;

				// name spec is [#numeric-]name[-#version][-context]
				p.fullname = x;
				if (!isNaN(parseInt(designation[di]))) {
					p.numeric = designation[di++];
				}

				p.id = designation[di++];

				p.version = parseInt(designation[di]);
				if (isNaN(p.version)) p.version = null;
				else ++di;

				p.context = designation[di] || header || null;

				// Use is a string of | separated designations.
				var msg = list.msg[x], use = msg.use.split("|");
				p.c2s = use.indexOf("C2S") != -1;
				p.s2c = use.indexOf("S2C") != -1;
				p.s2s = use.indexOf("S2S") != -1;
				p.c2c = use.indexOf("C2C") != -1;

				// Pull out all language entries and register them separately
				for (var lg in msg) {
					if (lg == "use") continue;
					
					var pp = packets.compilePacket(msg[lg]);
					pp.syntax = msg[lg];
					installedPackets.push(_(pp).assign(p).defaults(defaultPacket).value());
				}
			}
		}

		if ("specification" in list) {
			for (var x in list.specification) {
				installedSpecs[x] = list.specification[x];
			}
		}
	}

	// Retrieves a packet or packets from memory
	this.packet = function packet(command, heading) {
		// Command can be a single packet or an array of multiple
		// As a string, it's the packet name or numeric
		// As an object {
		//     "name": name or numeric
		//     "numeric": numeric specifically
		//     "id": textual name specifically
		//     "version": when multiple versions exist you may specify the number here
		//                normally it will return all of them sorted by spec relevance
		//     "heading": heading/context this packet falls under
		// }
		// Add read and write functions to return
		//  should try all if there's multiple...
		// Returns 0 if no packet exists
		// Returns false if packet isn't allowed by spec
		// TODO: BOILER
		if (!_.isArray(command)) command = [command];

		var spec = installedSpecs[self.server("specification")], found = [], filtered = false;
		for (var i = 0; i < command.length; ++i) {
			var lookup = {}, name = null;
			if (_.isObject(command[i])) {
				_(lookup).assign(_(command).omit("name"));
				if ("name" in command[i]) name = command[i].name;
			} else {
				name = command[i];
			}
			_(lookup).defaults({ "heading": heading });

			var results;
			if (name) {
				results = _.filter(installedPackets, _.assign({ "numeric": name }, lookup));
				results = _.union(results, _.filter(installedPackets, _.assign({ "id": name }, lookup)));
			} else {
				results = _.filter(installedPackets, lookup).value();
			}

			// Check spec...
			var yes = [], sorta = [], no = [];
			for (var j = 0; j < results.length; ++j) {
				var result = results[j]
				result.event = name || result.numeric || result.id;
				if (result.id in spec) {
					if (spec[result.id] == result.fullname) {
						yes.push(result);
					} else {
						sorta.push(result);
					}
				} else {
					no.push(result);
				}
			}

			found = found.concat(yes);
			if (self.server("strict")) filtered = filtered || sorta.length || no.length;
			else found = found.concat(sorta, no);
		}

		// Failure cases
		if (!found.length) {
			if (filtered) return false;
			else return 0;
		}

		return {
			"packets": found,

			"read": function (str) {
				for (var i = 0; i < found.length; ++i) {
					var tmp = packets.readPacket(found[i], str);
					if (tmp !== false && tmp.matched) {
						tmp.event = found[i].event;
						return tmp;
					}
				}
				return false;
			},

			"write": function (data) {
				for (var i = 0; i < found.length; ++i) {
					var tmp = packets.writePacket(found[i], data);
					if (tmp !== false) {
						tmp.event = found[i].event;
						return tmp;
					}
				}
				return false;
			},
		};
	}

	var myInfo = {
		"nickname": settings.nicknames[0],
		"nicknames": settings.nicknames,
		"nickpass": settings.nickpass,
		"password": settings.password,
		"username": settings.username || settings.nicknames[0],
		"mode": settings.mode || 0,
		"realname": settings.realname || settings.nicknames[0],
		"email": settings.email,
	}, nicknameIndex = 0;
	this.my = function my(property, value) {
		// BOILER
		var ret, assignedNick = false;
		if (_.isArray(property)) {
			// Return multiple properties
			return _.pick(myInfo, property);
		} else if (_.isObject(property)) {
			// Set multiple properties
			_(myInfo).assign(property);
			assignedNick = "nickname" in property || "nicknames" in property;
		} else if(_.isUndefined(value)) {
			// Return single property
			return myInfo[property];
		} else {
			// Set single property
			ret = myInfo[property] = value;
			assignedNick = "nickname" == property || "nicknames" == property;
		}

		if (assignedNick) {
			// Update index appropriately
			nicknameIndex = _(myInfo.nicknames).indexOf(myInfo.nickname);
		}

		return ret;
	}

	this.nextNick = function nextNick(loop) {
		var nicknames = my("nicknames");

		// Have we expended the list?
		if (nicknameIndex == -1 || ++nicknameIndex >= nicknames.length) {
			// Reset if we should loop
			if (loop) nicknameIndex = 0;

			// Otherwise return
			else {
				nicknameIndex = -1;
				return false;
			}
		}

		// Set and return the next nick TODO: BOILER
		return myInfo.nickname = nicknames[nicknameIndex];
	}

	// Return or set server related properties
	var serverInfo = {
		"servers": settings.servers,
		"specification": settings.specification,
	}, serverIndex = 0;
	this.server = function server(property, value) {
		// BOILER
		var ret;
		if (_.isArray(property)) {
			// Return multiple properties
			return _.pick(serverInfo, property);
		} else if (_.isObject(property)) {
			// Set multiple properties
			_(serverInfo).assign(property);
		} else if(_.isUndefined(value)) {
			// Return single property
			return serverInfo[property];
		} else {
			// Set single property
			ret = serverInfo[property] = value;
		}

		// If we set a server property, that needs to be split into address and port
		if ("server" in serverInfo) {
			var addrport = serverInfo.server.split(":");
			serverInfo.address = addrport[0];
			serverInfo.port = parseInt(addrport[1] || "6667");
		}

		return ret;
	}
	this.server("server", settings.servers[0]);

	this.nextServer = function nextServer(loop) {
		var servers = server("servers");

		// Have we expended the list?
		if (serverIndex == -1 || ++serverIndex >= servers.length) {
			// Reset if we should loop
			if (loop) serverIndex = 0;

			// Otherwise return
			else {
				serverIndex = -1;
				return false;
			}
		}

		// Set and return the next server
		return server("server", servers[serverIndex]);
	}

	// Wrapper for config("time")
	this.time = function time(property, defaultV) {
		return self.config("time", property, defaultV);
	}

	this.config = function config(header, property, defaultV) {
		// BOILER
		return defaultV;
	}

	this.plugins = function plugins() {
		// BOILER
		return settings.plugins;
	}

	this.supports = function supports(feature) {
		// BOILER
		return true;
	}

	var storage = {}
	this.store = function store(key, data) {
		// BOILER
		if (!(key in storage)) storage[key] = [];
		storage[key].push(data);
	}

	this.retrieve = function retrieve(key, query) {
		if (!(key in storage)) return [];
		return _.filter(storage, query);
	}

	this.forget = function forget(key, query) {
		if (key in storage {
			storage = _.reject(storage, query);
		}
		return true;
	}

	return this;
}