var _ = require("lodash");

// TODO:
//  something wrong with orsets
//  something wrong with escaping

////////////////////////////////// Exceptions //////////////////////////////////
var ERR_UNKNOWN = 0, ERR_UNMATCHED = 1, ERR_BADREF = 2, ERR_UNFINISHEDSET = 3, ERR_BADVALUE = 4;
function PacketBaseException(code, message) {
	var name = this.constructor.name;
	this.code = code;
	this.message = message;
	this.toString = function () {
		return name + ": " + message;
	}
	return this;
}

function PacketParserException(code, message) {
	return PacketBaseException.apply(this, arguments);
}

/////////////////////////////// Helper functions ///////////////////////////////
function indexOfNonEscaped(string, char, pos) {
	// Return the first index of char in string such that char is not preceeded by a %
	// Return -1 if one is not found.
	var idx = pos || -1;
	do {
		idx = string.indexOf(char, idx + 1)
	} while (idx != -1 && (idx > 0 && string.charAt(idx - 1) == "%"))
	return idx;
}

var jsName = /^[$_a-zA-Z][$_a-zA-Z0-9]*/

// http://stackoverflow.com/questions/3446170
function escapeRegExp(str, additionally) {
	return str.replace(new RegExp("[\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|" + (additionally || "") + "]", "g"), "\\$&");
}

function escapeDash(str) {
	return escapeRegExp(str).replace(/--/g, "\\-");
}

function unescapePacket(str, repl) {
	return str.replace(/%(.)/g, repl || "$1");
}

//////////////////////////////// Compile Packet ////////////////////////////////
function compilePacket(packet) {
	// Takes in a packet description and returns a RegExp and structure to write with.
	var pos = 0, regex = "", num2name = {}, name2regex = {}, curIdx = 0, orset = [];
	var source = packet;

	// Create the base structure...
	var structure = {
		"vars": {},
		"out": "",
		"children": []
	}, curStruct = structure;
	while (packet.length) {
		var angle = indexOfNonEscaped(packet, "<"),
		    brace = indexOfNonEscaped(packet, "{"),
		    lbrack = indexOfNonEscaped(packet, "["),
		    lparen = indexOfNonEscaped(packet, "("),
		    rbrack = indexOfNonEscaped(packet, "]"),
		    rparen = indexOfNonEscaped(packet, ")"),
		    slash = indexOfNonEscaped(packet, "/"),
		    order = _.sortBy([angle, brace, lbrack, lparen, rbrack, rparen, slash]);

		// Loop through what comes earliest...
		for (var i = 0; i < order.length; i++) {
			// Of course, we need to ignore anything that's not found
			if (order[i] == -1) continue;

			// If we're doing an option set, the groups need to be back to back
			if (orset.length && order[i] != 0) {
				throw new PacketParserException(ERR_UNFINISHEDSET, "Option set with a | but no following group.");
			}

			// Cut out the part until this position to place literally in struct out and regex
			var literal = unescapePacket(packet.substr(0, order[i]));
			curStruct.out += packet.substr(0, order[i]).replace(/%/g, "%%");
			regex += escapeRegExp(literal);

			// Record if there's a alternate separator. By default, it's space.
			var separator = " ";
			if (packet.charAt(order[i] + 2) == "|") {
				separator = packet.charAt(order[i] + 1)
				packet = packet.substr(order[i] + 3);
			} else if (packet.charAt(order[i] + 1) == "|") {
				// This form has no separator... limited use.
				separator = "";
				packet = packet.substr(order[i] + 2);
			}

			// Cut off the first character, too, since we know it
			else packet = packet.substr(order[i] + 1);

			var groupName = "", groupRE = "", postProcess = null, prepend = "", postpend = "", defaultV = null, right,
			    optional = false, groupStart = false, groupEnd = false, ignoreIdx = 0, thousands = "", decimal = "",
			    namedChild = false;

			switch (order[i]) {
			// Generally spaceless entries
			case angle:
				// Find the end.
				right = indexOfNonEscaped(packet, ">");
				if (right == -1) throw new PacketParserException(ERR_UNMATCHED, "Unmatched <");

				// Check if this is meant to be numeric.
				var numeric = false;
				if (packet.charAt(0) == "#") {
					numeric = true;
					--right;
					packet = packet.substr(1);
				} else if (packet.charAt(0) == "{") {
					// This is a special grouper that inlays a named child.
					if (packet.charAt(right - 1) != "}") {
						throw new PacketParserException(ERR_UNMATCHED, "Unmatched <{");
					}
					namedChild = true;
					--right;
					packet = packet.substr(1);
				}

				// Extract the name.
				groupName = (packet.match(jsName) || [""])[0];

				// Named children don't accept mods
				if (namedChild) {
					if (groupName.length + 1 < right) {
						throw new PacketParserException(ERR_UNKNOWN, "<{}> does not accept modifiers.");
					}
					groupRE = ".+?";
					break;
				}

				// Handle options.
				var mod = unescapePacket(packet.substring(groupName.length + 1, right));
				var modder = packet.charAt(groupName.length), negative = "";

				switch (modder) {
				case ">":
					if (numeric) groupRE = "[0-9]+?";
					else groupRE = "[^ ]+?";
					break;

				case ":":
					if (numeric) {
						// Include (and handle) thousands and decimal separators.
						thousands = mod.charAt(0);
						decimal = mod.charAt(1);
						switch (mod.length) {
						case 0: groupRE = "[0-9]+?"; break;
						case 1: groupRE = "[0-9" + escapeRegExp(thousands, "\\-") + "]+?"; break;
						case 2: groupRE = "[0-9" + escapeRegExp(thousands, "\\-") + "]+?" + escapeRegExp(decimal) + "?[0-9]*?"; break;
						default: throw new PacketParserException(ERR_UNKNOWN, "Excepts only up to two characters in <#:>");
						}
					} else {
						// Also disclude these characters.
						groupRE = "[^ " + escapeDash(mod) + "]+?";
					}
					break;

				case "!":
					// Only disclude these characters.
					negative = "^";
					//fall
				case "=":
					// Only include these characters
					if (numeric) throw new PacketParserException(ERR_UNKNOWN, "Unknown modifier '" + modder + "' for <#>");

					// + is literal if it's the only thing, otherwise people can put it in the front for a literal.
					if (mod.charAt(mod.length - 1) == "+" && mod.length > 1) {
						groupRE = "[" + negative + escapeDash(mod.slice(0, -1)) + "]+?";
					} else {
						groupRE = "[" + negative + escapeDash(mod) + "]";
					}
					break;

				case "@":
					// Inherit the ruleset of something else.
					if (numeric) throw new PacketParserException(ERR_UNKNOWN, "Unknown modifier '" + modder + "' for <#>");
					if (!(mod in name2regex)) throw new PacketParserException(ERR_BADREF, "Unknown field '" + mod + "' referenced by <" + groupName + ">");
					groupRE = name2regex[mod];
					break;

				default: throw new PacketParserException(ERR_UNKNOWN, "Unknown modifier '" + modder + "' for " + (numeric ? "<#>" : "<>"));
				}

				// If it's numeric, set up the post processor.
				if (numeric) postProcess = genProcessNumber(thousands, decimal);
				break;

			case brace:
				// Find the end.
				right = indexOfNonEscaped(packet, "}");
				if (right == -1) throw new PacketParserException(ERR_UNMATCHED, "Unmatched {");

				// Extract the name.
				groupName = (packet.match(jsName) || [""])[0];

				// Handle options.
				var mod = unescapePacket(packet.substring(groupName.length + 1, right));
				var modder = packet.charAt(groupName.length), negative = "";

				var comma = "";
				switch (modder) {
				case "}":
					groupRE = ".+";
					break;

				case ":":
					// May only contain up to mod spaces.
					comma = "0,"
					//fall
				case "=":
					// Must contain exactly mod spaces.
					mod = parseInt(mod);
					if (mod == 0) groupRE = ".+";
					else if (isNaN(mod)) {
						throw new PacketParserException(ERR_BADVALUE, "Modifier value for {:} and {=} must be a number.");
					} else {
						groupRE = "[^ ]+( [^ ]+){" + comma + mod.toString() + "}";
						++ignoreIdx;
					}
					break;

				case "?":
					// In order to match spaces, it must match the condition on the given side of the entry
					var qOptional = mod.charAt(0) == "?",
					    qLeft = mod.charAt(0 + qOptional) == "<";
					    qRight = mod.charAt(0 + qOptional) == ">";
					mod = mod.substr(qOptional + qLeft + qRight);

					if (qOptional) defaultV = "";
					qOptional = qOptional ? "*" : "+"

					if (qRight) {
						postpend = mod;
						groupRE = "(." + qOptional + mod + "|[^ ]*[^ " + escapeRegExp(mod, "\\-") + "])";
					} else {
						prepend = mod;
						groupRE = "(" + mod + "." + qOptional + "|[^ " + escapeRegExp(mod, "\\-") + "][^ ]*)";
					}
					postProcess = genTrimmer(prepend, postpend);
					++ignoreIdx;
					break;

				default: throw new PacketParserException(ERR_UNKNOWN, "Unknown modifier '" + modder + "' for {}");
				}
				break;

			case lbrack:
				optional = true;
				//fall
			case lparen:
				var newStruct = {
					"vars": {},
					"out": "",
					"children": [],
					"parent": curStruct
				};
				if (optional) newStruct.optional = optional;

				curStruct.children.push(newStruct);
				curStruct = newStruct;

				// Add a grouping for this to the regex.
				regex += "(";
				++curIdx;
				groupStart = true;
				break;

			case rbrack:
				optional = true;
				//fall
			case rparen:
				right = -1;
				groupEnd = true;
				break;

			case slash:
				// Find the end.
				right = indexOfNonEscaped(packet, "/");
				if (right == -1) throw new PacketParserException(ERR_UNMATCHED, "Unmatched /");

				// Extract the name.
				groupName = (packet.match(jsName) || [""])[0];

				var modder = packet.charAt(groupName.length);
				switch (modder) {
				case ":": break;
				case "/": throw new PacketParserException(ERR_UNKNOWN, "Regular expression required for //");
				default: throw new PacketParserException(ERR_UNKNOWN, "Unknown modifier '" + modder + "' for //");
				}

				groupRE = unescapePacket(packet.substring(groupName.length + 1, right), "\\$1");
				// TODO: count groups
			}

			// Don't want to do anything for opening ( [
			if (!groupStart) {
				// Check repeats and options
				var repeat = false, breaking = false, options = false, mo;
				packet = packet.substr(right + 1);
				mo = packet.match(/^([*~]*)(\|?)/);

				repeat = mo[1].indexOf("*") != -1;
				breaking = mo[1].indexOf("~") != -1;
				options = !!mo[2];
				packet = packet.substr(mo[0].length);

				if (groupEnd) {
					var oldStruct = curStruct;
					curStruct = oldStruct.parent;
					delete oldStruct.parent;
					if (oldStruct.children.length == 0) delete oldStruct.children;
				}
				// At this point curStruct is always the struct we're working inside of.

				// If this is a new option set...
				if (options && orset.length == 0) {
					// we need to offset the group number by 1 to account for the option set's group.
					++curIdx;
					// and recreate the curStruct as a list.
					curStruct.out += "%(" + (curStruct.children.length - 1).toString() + ")";
					if (groupEnd) {
						curStruct.children.push([ curStruct.children.splice(-1) ]);
					} else {
						curStruct.children.push([]);
					}
				} else if (groupEnd) {
					// Add this child to the out.
					curStruct.out += "%(" + (curStruct.children.length - 1).toString() + ")";
				}

				if (!groupEnd) {
					// Generate a group name for use in the structure
					var fakeGroupName = groupName, editStruct = curStruct;
					if (!fakeGroupName) {
						if (!("?#" in curStruct)) curStruct["?#"] = 0;
						fakeGroupName = "?" + (++curStruct["?#"]).toString();
					}

					if (options || orset.length) {
						// If there is currently an options set and this is a <> or {} we need to make it its own group
						editStruct = {
							"vars": {},
							"out": "",
							"children": [],
						};
						curStruct.children.slice(-1)[0].push(editStruct);
					}
					editStruct.vars[fakeGroupName] = { "match": groupRE };
					if (prepend) editStruct.vars[fakeGroupName].prepend = prepend;
					if (postpend) editStruct.vars[fakeGroupName].postpend = postpend;
					if (defaultV) editStruct.vars[fakeGroupName].default = defaultV;
					if (repeat) editStruct.vars[fakeGroupName].separator = separator;
					if (breaking) editStruct.vars[fakeGroupName].breaking = true;
					if (thousands) editStruct.vars[fakeGroupName].thousands = thousands;
					if (decimal) editStruct.vars[fakeGroupName].decimal = decimal;
					if (namedChild) editStruct.vars[fakeGroupName].namedChild = true;
					editStruct.out += "%(" + fakeGroupName + ")";

					// If this is named, it must be remembered and registered.
					if (groupName) {
						name2regex[groupName] = groupRE;
						num2name[++curIdx] = { "name": groupName };
					}

					// Update the RegExp to use repeats and stuff.
					if (repeat) {
						groupRE = "(" + groupRE + "(" + escapeRegExp(separator) + groupRE + ")*?)";
						postProcess = genSplitter(separator);
						++ignoreIdx;
					} else {
						groupRE = "(" + groupRE + ")";
					}

					if (groupName && postProcess) num2name[curIdx]["postProcess"] = postProcess;

					curIdx += ignoreIdx;
				}

				// If this is currently an options set, add this to it.
				if (options || orset.length) {
					orset.push(groupRE);

					// However, if this is the last option, we can commit it now.
					if (! options) {
						regex += "(" + orset.join("|") + ")";
						orset = [];
					}
				}

				// Otherwise stick it onto the main regex immediately.
				else {
					regex += groupRE;
				}

				if (groupEnd) {
					// Add the group closing for this to the regex.
					regex += ")";
					if (optional) regex += "?";
				}
			}

			// We should only really deal with the first that worked.
			break;
		}

		// No groups left
		if (i == order.length) {
			// Write the rest of the literal
			var literal = unescapePacket(packet);
			curStruct.out += literal.replace(/%/g, "%%");
			regex += escapeRegExp(literal);
			packet = "";
		}
	}

	try {
		return {
			"regex": new RegExp("^" + regex + "$"),
			"num2name": num2name,
			"structure": structure
		};
	} catch (e) {
		console.log(e.message, source);
		return {};
	}
}

function genProcessNumber(thousands, decimal) {
	var replaceThousands = new RegExp(escapeRegExp(thousands), "g");
	return function (n) {
		n = n.replace(replaceThousands, "");
		if (decimal) n = n.replace(decimal, ".");
		return (decimal ? parseFloat : parseInt)(n);
	}
}

function genTrimmer(prepend, postpend) {
	var pre = new RegExp("^" + escapeRegExp(prepend)),
	    post = new RegExp(escapeRegExp(postpend) + "$");
	return function (s) {
		return s.replace(pre, "").replace(post, "");
	}
}

function genSplitter(separator) {
	return function (s) {
		return s.split(separator);
	}
}

///////////////////////////////// Read Packet //////////////////////////////////
function readPacket(description, packet) {
	// Apply RegExp to extract numbered groups.
	var mo = packet.match(description.regex), ret = {};

	// Convert them to named groups. If only JS's RegExp supported this itself, right?
	if (mo !== null) {
		for (var i = 1; i < mo.length; ++i) {
			if (i in description.num2name) {
				var v = description.num2name[i], name = v.name, d = mo[i];

				// Don't add it if there was nothing there.
				if (typeof(d) === "undefined") continue;

				// If there's a post processor, run it.
				if ("postProcess" in v) d = v.postProcess(d);

				// Assert equivalence between groups of the same name.
				if (name in ret && !_.isEqual(ret[name], d)) {
					// Failed, return failure to match.
					ret = {};
					mo = null;
					break;
				}
				ret[name] = d;
			}
		}
	}
	ret.matched = mo !== null;

	return ret;
}

///////////////////////////////// Write Packet /////////////////////////////////
function writePacket(description, data, extraChildren) {
	// description.structure has three entries: vars, out, children, and optional
	// vars describes the required variables at this point in the context
	//  each key is a variable name or of the form ?# for unnamed structures
	//  variable descriptions have the entries: match, prepend, postpend, default, and separator
	//  match is the regex as a string to verify the data
	//  prepend and postpend adjust the data accordingly
	//  default implies that omitting this value is okay and supplies the value in that case
	//  separator implies the input data can be an array and joins the elements with this in that case
	//  thousands and decimal indicate the character to represent these separators in numbers
	// out describes the format for the return string from this context
	//  %(name) puts a variable of that name at this point
	//  %(#) puts the result of a child at this point
	// children is an array of children of either this same object format or an array of
	//  options that are this object format

	return tryWritingSection(description.structure, data, extraChildren);
}

function modify(d, v) {
	if ("prepend" in v) d = v.prepend + d;
	if ("postpend" in v) d += v.postpend;

	if ("thousands" in v) {
		var x, j = "";
		if ("decimal" in v) {
			x = d.split(".", 2);
			j = v.decimal;
		} else {
			x = [d];
		}

		// Group into 3s, right-bounded
		var e = []
		d = x[0].split("");
		while (d.length) {
			e.unshift(d.splice(-3).join(""));
		}

		// Join by the thousands separator
		x[0] = e.join(v.thousands);

		// Join by the decimal separator
		d = x.join(j);
	}
	

	return d;
}

function tryWritingSection(section, data, extraChildren) {
	if ("structure" in section) section = section.structure;
	else if ("packets" in section) {
		for (var i = 0; i < section.packets.length; ++i) {
			var tmp = tryWritingSection(section.packets[i], data, extraChildren);
			if (tmp !== false) return tmp;
		}
		return false;
	}

	// Loop through vars segment, make sure all data is present and checks out.
	var using = {}, usingv = {};
	for (var name in section.vars) {
		var v = section.vars[name], d = undefined;

		// First, existence...
		if (name in data) {
			d = data[name];
		}

		if (_.isUndefined(d) && "default" in v) {
			d = v.default;
		}

		if (_.isUndefined(d)) {
			// No good
			//console.log("Looking for", name)
			return false;
		}

		// If it's a namedChild, we shouldn't verify.
		if (!v.namedChild && !_.isObject(d)) {
			// Verify...
			var regex = new RegExp("^" + v.match + "$");
			if (_.isArray(d)) {
				// This is the Array case
				if (!("separator" in v) || !v.separator) {
					// Arrays aren't allowed.
					//console.log("Arrays aren't allowed.")
					return false;
				}

				// Check each entry.
				for (var i = 0; i < d.length; ++i) {
					d[i] = modify(d[i].toString(), v);
					if (!d[i].match(regex)) return false;
				}

				// Combine into a string.
				d = d.join(v.separator);
			} else {
				// Modify before checking.
				d = modify(d.toString(), v);
				if (!d.match(regex)) {
					//console.log("Invalid data for " + name + ":", d)
					return false;
				}
			}
		} else {
			usingv[name] = v;
		}

		// Looks okay! Store it.
		using[name] = d;
	}

	// If we got to here, this section checks out so far. Now we need to write it out.
	try {
		// TODO: This goes with the earliest match instead of the best fit.
		// This can be circumvented by recording and passing around the number of replacements
		// in a child and choosing the form with the most out of the successful ones.
		// That might be unexpected behavior in some instances though.
		return section.out.replace(/(%%)|%\(([^\)]+)\)/g, function (m, escaped, name) {
			// First, verify this isn't escaped.
			if (escaped) {
				// It is! Return the single percent.
				return "%";
			}

			// Next, check if this is a child.
			var num = parseInt(name), namedChild = name in section.vars && section.vars[name].namedChild || _.isObject(using[name]);
			if (isNaN(num) && !namedChild) {
				// Not a child, splice in its value. (We can assume it exists.)
				return using[name];
			} else {
				// Is a child, verify the child.
				var child, out;
				if (namedChild) child = using[name];
				else child = section.children.concat(extraChildren || [])[num];

				// Is this an option set?
				if (_.isArray(child)) {
					// Yes, use the first one that's satisfied.
					var optional = false;
					for (var i = 0; i < child.length; ++i) {
						out = tryWritingSection(child[i], data);
						if (out !== false) break;
						if (child[i].optional) optional = true;
					}
					if (out === false && optional) out = "";
				} else {
					// No, just check the one.
					out = tryWritingSection(child, data);
					if (out === false && child.optional) out = "";
				}

				// If it failed, break out.
				if (out === false) throw "fail";

				// Otherwise, splice it in.
				else if (namedChild) return modify(out, usingv[name]);
				else return out;
			}
		});
	} catch (e) {
		// A child failed to match.
		//console.log("Some child failed.")
		if (e === "fail") return false;
		throw e;
	}
}

module.exports = {
	"compilePacket": compilePacket,
	"readPacket": readPacket,
	"writePacket": writePacket,
}