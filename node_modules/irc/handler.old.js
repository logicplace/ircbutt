var
	Class = require("class")
	,proto = require("./proto.js")
	,settings = require("./settings.js")
	,net = require("net")
	,path = require("path");
;

/*
function dispatchEvents(sock,events,base,context);
 - Loops through given events and dispatches them in prioritized order.
 - sock = Socket that triggered the event
 - events = Array of five arrays signifying priority, each containing sets of [module,handler]
 - - module = Registering module's name
 - - handler = Function to call, should accept function(data[,sender[,command]])
 - base = Object containing {command:""[,args:""][,sender:""]}
 - context = Settings context
Class handler(settings)
 - Class to handle an IRC instance, be it one outbound connection or multiple inbound
 - When hosting, events are per server instance
 
*/

function dispatchEvents(events,base,context,sock){
	//Each event has 5 priority levels
	if(!(base.command in events))return false;
	var event = events[base.command],ret,ep,tmp=null,spltr; //Event[Priority]
	spltr = whichSpec(base.command,context);
	if(spltr && "args" in base){
		//Handle numberics
		if(base.command.match(/^[0-9]+$/)){
			tmp = proto.msgs.$numeric.read(base.args);
			base.args = ("args" in tmp)?tmp.args:"";
		}
		if(base.args)base.args = spltr.read(base.args);
		//More numerics handling
		if(tmp){
			//TODO: Check if it already exists?
			base.args.nick = tmp.nick;
		}
	}
	for(var p=0;p<5;++p){ //Priority
		ep = event[p];
		for(var i=0;i<ep.length;++i){
			//NOTE: If a module changes this (base.args) it changes it
			//+for subsequent modules. Is this bad?
			var module = ep[i][0];
			var modules = context.modules;
			if(modules.hasOwnProperty(module) && modules[module].enabled){
				ep[i][1].call(sock,base.args,("sender" in base)?base.sender:"",base.command);
			}
		}
	}
}

function whichSpec(command, settings){
	var spec = settings.spec;
	for(var i=0;i < spec.length && !(command in proto.spec[spec[i]]);++i);
	if(i < spec.length)return proto.spec[spec[i]][command];
	else return null;
}

module.exports = Class({
	init: function(settingsFile/*, basePath*/,callback){
		var tmp = function(context){
			this.settings = context;
			this.sesKnow = { //Session Knowledge
				serverID: 0,
				connected: false,
				flood: 0,
				floodCnt: 0,
			};
			this.connections = {
				id: {}, nick: {}
			}
			this.connID = 0;
			this.events = {};
			this.sender = null;
			// This needs to be an absolute path
			this.basePath = path.dirname(process.argv[1]);
			this.initModules();
		}
		if(typeof(settingsFile) == "string"){
			settings.loadFile(settingsFile,tmp);
		} else tmp(settingsFile);
		callback.call(this);
	},

	initModules: function() {
		var modules = this.settings.modules;
		for(var module in modules){
			if(modules.hasOwnProperty(module)){
				this.loadModule(modules[module]);
			}
		}
	},

	_modPath: function(module) {
		return path.normalize(path.join(this.basePath, 'modules', module + '.js'));
	},

	loadModule: function(module) {
		var m = require(this._modPath(module));
		m.register(this);
		this.enableModule(module);
	},

	unloadModule: function(module) {
		var mpath = this._modPath(module);
		var m = require(mpath);
		m.unregister(this);
		this.disableModule(module);
		delete require.cache[path];
	},

	enableModule: function(module) {
		var modules = this.settings.modules;
		if(modules.hasOwnProperty(module)){
			modules[module].enabled = true;
		}
	},

	disableModule: function(module) {
		var modules = this.settings.modules;
		if(modules.hasOwnProperty(module)){
			modules[module].enabled = false;
		}
	},

	connect: function(){
		this.server = false;
		(this.conn = new net.Socket())
		.on("connect",this.onConnect)
		.connect(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID]
		)
		;
	},

	host: function(){
		this.server = true;
		(this.conn = net.createServer(this.onConnect))
		.on("error",this.onError)
		.listen(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID],this.onSuccess
		)
		;
		//Each connection will have its own buffers
	},

	onSuccess: function(){
		this.sesKnow.connected = true;
		this.sesKnow.host = this.settings.host[sesKnow.serverID];
		this.sesKnow.ports = this.settings.port[sesKnow.serverID];
	},

	restart: function(){
		if(server){
			this.conn.close();
			this.host();
		} else {
			this.conn.end();
			this.connect();
		}
	},

	on: function(modName,event,priority,handler){
		if(arguments.length == 3){
			handler = priority;
			priority = 2;
		}
		event = event.toUpperCase();
		if(event.charAt(0) != "_" && event.charAt(0) != "$"){
			var spltr = whichSpec(event,this.settings);
			if(spltr){
				if(event in this.events){
					this.events[event][priority].push([modName,handler]);
				} else {
					//Create five priorities
					this.events[event] = [[],[],[],[],[]];
				}
			}
		}
	},

	//Socket commands
	send: function(sock,command,data,priority){
		if(typeof(data) == "undefined")data = {};
		if(typeof(priority) == "undefined")priority = 2;
		command = command.toUpperCase();
		var proCom = whichSpec(command,this.settings);
		if(proCom){
			var msg = proCom[1];
			var mode = this.server?"$server":"$client",raw;
			//Split by settings (context aware)
			// 1) Check length of the unsplitable parts of the messages
			// 2) Pass available length to handler function
			if(proCom.length > 2){
				var except = proCom[2][0]
				,arg = msg.write(data,except)
				,len = proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: arg
				}).length;
				data[except] = proCom.split[1](
					this.settings.flood.chars[this.sesKnow.flood]-len,
					data[except]
				);

				raw = proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.write(data)
				});
			} else {
				raw = proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.write(data)
				});
			}
			/*if(this.server){ //Actually daemon manages channels right? So this should go there..
				//TODO: Figure out who this message applies to by nick, channel, etc
				if("target" in data){
					for(var i=0;i<data.target.length;++i){
						var dti = data.target[i];
						if("channel" in dti){
							//TODO: Find all connections in a channel
						} else if("user" in dti) {
							//TODO: Find all connections matching this hostmask
						} else if("nick" in dti) {
							//TODO: Find connection of this nick
						}
						this.sendRaw(raw,priority,con);
					} 
					//TODO: etc
				} else if(typeof(sock) != "undefined"){
					return this.sendRaw(raw,priority,sock);
				} else {
					//TODO: Error?
				}
			} else {
				return this.sendRaw(raw,priority,this.conn);
			}*/
			switch(typeof(sock)){
				case "undefined": {
					this.sendRaw(this.conn,raw,priority);
					break;
				} case "object": {
					if(Array.isArray(sock)){
						for(var i=0;i<sock.length;++i){
							this.sendRaw(sock[i],raw,priority);
						}
					} else {
						this.sendRaw(sock,raw,priority);
					}
					break;
				}
			}
		}
		return false
	},

	sendRaw: function(sock,str,priority){
		//Ensure this is below max length
		str = str.substr(0,this.settings.flood.chars[this.sesKnow.flood])
		if(typeof(priority) == "undefined")priority = 2;
		sock.writeBuffer[priority].push(str);
		//Start send off if there isn't a queue
		if(!this.sender)this._send(sock);
	},

	//Internal function that sends off the write queue
	_send: function(sock){
		//TODO: Lock this function so it can't be running
		//+multiple times in tandem?
		var len = this.settings.flood.amount;
		if(this.sesKnow.floodCnt >= len){
			this.sesKnow.flood = 1;
		}
		var fld = this.sesKnow.flood
		, wait = this.settings.flood.wait[fld]
		, tcwb = sock.writeBuffer
		,i=0,p,wb,l,wr="";
		//If amount is 0, send off all messages at once
		if(len == 0){
			len = tcwb[0].length
			+ tcwb[1].length
			+ tcwb[2].length
			+ tcwb[3].length
			+ tcwb[4].length;
		}
		for(p=0;p<5;++p){
			wb = tcwb[p];
			if(wait){
				if(wb.length)wr = wb.shift();
			} else {
				while(wb.length && i<len){
					wr += wb.shift();
					++i;
				}
			}
		}
		sock.write(wr);
		if(tcwb[0].length
			+ tcwb[1].length
			+ tcwb[2].length
			+ tcwb[3].length
			+ tcwb[4].length
		){
			this.sender = setTimeout(this._send,wait);
			this.sesKnow.floodCnt += 1;
		} else {
			this.sesKnow.flood = 0;
			this.sesKnow.floodCnt = 0;
		}
	},

	//Socket events
	onConnect: function(sock){
		if(!server){
			sock = this.conn;
			this.onSuccess();
		}
		sock.on("data",this.onData);
		sock.on("end",this.onEnd);
		sock.on("timeout",this.onTimeout);
		sock.on("drain",this.onDrain);
		sock.on("error",this.onError);
		sock.on("close",this.onClose);

		sock.readBuffer = "";
		sock.writeBuffer = [[],[],[],[],[]];
		sock.id = ++this.connID;
		sock.sesKnow = this.connections.id[sock.id] == {};
	},

	onData: function(data){
		var sock = this.this;
		data = (sock.readBuffer+data).split("\r\n");
		sock.readBuffer = data.pop();
		var mode = this.server?"$client":"$server"
		, spec = this.settings.spec;
		for(var i=0;i<data.length;++i){
			var base = proto.msgs[mode].read(data[i]);
			if(base == null)continue; //Error stuff
			//var args = proto._args.read(base.args);
			dispatchEvents(this.events,base,this.settings,sock);
		}
	},

	onEnd: function(){
	},

	onTimeout: function(){
		//TODO: Restart I guess?
	},http://www.youtube.com/watch?v=tYmvEHZF35I

	onDrain: function(){
	},

	onError: function(error){
		this.closedByError = true; //To know to restart
		switch(e.code){
			case "EADDRINUSE": case "ECONNREFUSED": {
				if(e.code == "EADDRINUSE"){
					console.log("ERROR: Address in use, trying next in sequence...");
				} else {
					console.log("ERROR: Connection refused, trying next in sequence...");
				}
				//Increase and loop serverID as necessary
				if(++this.sesKnow.serverID >= this.settings.port.length){
					this.sesKnow.serverID = 0;
				}
				setTimeout(this.restart,1000);
			}
		}
	},

	onClose: function(hadError){
		if("closedByError" in this){
			delete this.closedByError;
			this.restart();
		}
	},
});
