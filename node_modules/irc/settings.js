var
	fs = require("fs")
	, jslon = require("jslon")
;

var settings = null;

function getParentProp(x){
	var tmp = this;
	while("_parent" in tmp && !(x in tmp._parent)){
		tmp = tmp._parent;
	}
	if("_parent" in tmp)return this._parent[x];
	else return undefined;
}
function _getParentProp(x){
	return function(){ return getParentProp.call(this,x); };
}

function setSelf(x,y){
	if(x in this)delete this[x];
	this[x] = y;
}
function _setSelf(x){
	return function(y){ return setSelf.call(this,x,y); };
}

// Do a normalization check for a context field that can only be one type or in
// a set of values. If typeOrValues is a string, it does a type check.
// Otherwise, it checks to see if the value is in an array of values.
function normalizeValue(context,def,field,typeOrValues,defValue){
	if (field in context){
		if(typeof(typeOrValues) == "string"){
			if(typeof(context[field]) != typeOrValues){
				throw TypeError(field + " must be a " + typeOrValues);
			}
		} else if(Array.isArray(typeOrValues)){
			for(var i = 0; i < typeOrValues.length; i++){
				if (typeOrValues[i] === context[field]){
					return;
				}
			}
			// TODO: not really a type error
			throw TypeError(field + " is not in set: " + typeOrValues);
		} else {
			throw TypeError("typeOrValues must be string or array");
		}
	} else if(def) context[field] = defValue;
}

//Normalizes settings so that access method is consistent
function normalize(context,def){
	var i,len,x,tmp;
	/** HOST **
	* Network to connect to
	* Port is optional, defaults to 6667
	* Accepts string, array
	**/
	if("host" in context){
		context.port = [];
		//Make strings into an array usable below
		if(typeof(context.host) == "string"){
			context.host = [context.host];
		}
		//Enumerate possible addresses array
		if(Array.isArray(context.host)){
			len = context.host.length;
			for(i=0;i<len;++i){
				x = context.host[i];
				if(typeof(x) == "string"){
					tmp = (context.host+":6667").split(":",2);
					context.host[i] = tmp[0]==""?null:tmp[0];
					context.port[i] = tmp[1];
				} else {
					throw TypeError("host array must only contain strings");
				}
			}
		} else {
			throw TypeError("host must be string or array");
		}
	} else if(def)context.host = undefined;

	/** CHANNEL **
	* Channel(s) to connect to
	* Accepts string, array
	**/
	if("channel" in context){
		if(typeof(context.channel) == "string"){
			context.channel = [context.channel];
		} else if(!Array.isArray(context.channel)){
			throw TypeError("channel must be string or array");
		}
	} else if(def)context.channel = undefined;

	/** NICK **
	* Nickname(s) to use
	* Accepts string, array
	* If all nicks are taken and nothing can be done about it, fail connection
	**/
	if("nick" in context){
		if(typeof(context.nick) == "string"){
			context.nick = [context.nick];
		}
		tmp = context.nick;
		len = tmp.length;
		for(i=0;i<len;++i){
			if(typeof(tmp[i]) == "string"){
				tmp[i] = [tmp[i],null];
			} else if(Array.isArray(tmp[i])){
				if(tmp[i].length > 2)tmp[i].length = 2;
				else if(tmp[i].length == 1)tmp[i].push(null);
				else if(tmp[i].length == 0)tmp[i].extend = [undefined,null];
			} else if(tmp[i].constructor.name == "Object"){
				for(x in tmp[i]){
					tmp[i] = [x,tmp[i][x]];
					break;
				}
			}
		}
	} else if(def)context.nick = undefined;

	/** USER **
	* Username to register as
	* If ident is enabled, it will fall back to this for the username
	* Accepts string
	*** USERMODE **
	* http://tools.ietf.org/html/rfc2812#section-3.1.5
	* Accepts string, number
	*** REAL **
	* Real name
	* Accepts string
	**/
	// TODO: no normalizeValue calls set defaults right now
	normalizeValue(context,def,"user","string");
	if("usermod" in context){
		// TODO: fill in
		if(typeof(context.usermod) == "string"){
		} else if(typeof(context.usermod) == "number"){
		} else {
			throw TypeError("usermod must be a string or number");
		}
	} else if(def); // TODO

	normalizeValue(context,def,"real","string");
	/** PASS **
	* Connection pass
	* Does not send a pass if omitted or blank
	* Accepts string
	**/
	normalizeValue(context,def,"pass","string");

	if("passwords" in context){
		if(typeof(context.passwords) == "string"){
			context.passwords = [context.passwords];
		} else if(Array.isArray(context.passwords)){
			tmp = context.passwords;
			len = tmp.length;
			for(i=0;i<len;++i){
				if(typeof(tmp[i]) != "string"){
					throw TypeError("passwords array must contain strings");
				}
			}
		} else {
			throw TypeError("passwords must be string or array of strings");
		}
	} else if(def) context.passwords = [];
	normalizeValue(context,def,"remotePass","string");

	if(remoteWeb in context) {
		tmp = context.remoteWeb;
		for(var user in tmp){
			if(tmp.hasOwnProperty(user)){
				if(typeof(tmp[user]) != "string"){
					throw TypeError("remoteWeb passwords must be strings");
				}
			}
		}
	} else if(def) context.remoteWeb = {};

	normalizeValue(context,def,"spec",["rfc1459","rfc281x"]);
	normalizeValue(context,def,"hostIdent","boolean");
	// TODO: May want to impose limits on what can be used as a prefix?
	normalizeValue(context,def,"prefix","string");
	normalizeValue(context,def,"logAll","boolean");
	normalizeValue(context,def,"logCommands","boolean");
	normalizeValue(context,def,"logConvo","boolean");
	normalizeValue(context,def,"logErrors","boolean");
	normalizeValue(context,def,"logAuth","boolean");
	normalizeValue(context,def,"logDebug","boolean");

	//TODO: commands, flood, remoteUserDB, authMethod
	// modules
}

function bubblesTo(obj,key){
	//NOTE: This could throw an exception if you don't pass a settings object
	// I don't care about you if you're that stupid
	while(key in obj && obj.__lookupGetter__(key)){
		obj = obj._parent;
	}
	return obj;
}

function loadFile(file){
	fs.readFile(file,function(err,data){
		if(err)throw err;
		var root = jslon.parse(data);
		//Lowest children are most important
		//Trace heirarchy backwards to bubble up
		settings = [];
		function recurse(x,nom){
			x._name = nom;
			if("$" in x){
				x.$._parent = x;
				for(var i in x.$){
					var child = x.$[i];
					for(var j in x){
						//Add a bubbler for attributes the parent has
						// but the child doesn't
						if(j.charAt(0) != "_" && !(j in child)){
							child.__defineGetter__(j,_getParentProp(j));
							child.__defineSetter__(j,_setSelf(j));
						}
					}
					recurse(child,i);
				}
			} else {
				settings.push(x);
			}
		}
		recurse(root,"root");
	});
}

function load(){
	//TODO: Load from database
}

//TODO: Save functions

module.exports = {
	bubblesTo: bubblesTo,
	loadFile: loadFile,
}
