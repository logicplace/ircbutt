var
	fs = require("fs")
	, jslon = require("jslon")
;

var settings = null;

function getParentProp(x){
	var tmp = this;
	while("_parent" in tmp && !(x in tmp._parent)){
		tmp = tmp._parent;
	}
	if("_parent" in tmp)return this._parent[x];
	else return undefined;
}
function _getParentProp(x){
	return function(){ return getParentProp.call(this,x); }
}

function setSelf(x,y){
	if(x in this)delete this[x];
	this[x] = y;
}
function _setSelf(x){
	return function(y){ return setSelf.call(this,x,y); }
}

//Normalizes settings so that access method is consistent
function normalize(context,def){
	var i,len,x,tmp;
	/** HOST **
	* Network to connect to
	* Port is optional, defaults to 6667
	* Accepts string, array
	**/
	if("host" in context){
		context.port = [];
		//Make strings into an array usable below
		if(typeof(context.host) == "string"){
			context.host = [context.host]
		}
		//Enumerate possible addresses array
		if(Array.isArray(context.host)){
			len = context.host.length;
			for(i=0;i<len;++i){
				x = context.host[i];
				if(typeof(x) == "string"){
					tmp = (context.host+":6667").split(":",2);
					context.host[i] = tmp[0]==""?null:tmp[0];
					context.port[i] = tmp[1];
				} else {
					throw TypeError("host array must only contain strings");
				}
			}
		} else {
			throw TypeError("host must be string or array");
		}
	} else if(def)context.host = undefined;
	
	/** CHANNEL **
	* Channel(s) to connect to
	* Accepts string, array
	**/
	if("channel" in context){
		if(typeof(context.channel) == "string"){
			context.channel = [context.channel]
		} else if(!Array.isArray(context.channel)){
			throw TypeError("channel must be string or array");
		}
	} else if(def)context.channel = undefined;
	
	/** NICK **
	* Nickname(s) to use
	* Accepts string, array
	* If all nicks are taken and nothing can be done about it, fail connection
	**/
	if("nick" in context){
		if(typeof(context.nick) == "string"){
			context.nick = [context.nick];
		}
		tmp = context.nick;
		len = tmp.length;
		for(i=0;i<len;++i){
			if(typeof(tmp[i]) == "string"){
				tmp[i] = [tmp[i],null];
			} else if(Array.isArray(tmp[i])){
				if(tmp[i].length > 2)tmp[i].length = 2;
				else if(tmp[i].length == 1)tmp[i].push(null);
				else if(tmp[i].length == 0)tmp[i].extend = [undefined,null];
			} else if(tmp[i].constructor.name == "Object"){
				for(x in tmp[i]){
					tmp[i] = [x,tmp[i][x]];
					break;
				}
			}
		}
	} else if(def)context.nick = undefined;
	
	//TODO: user, usermode, real, pass, commands, flood, passwords
	// remotePass, remoteWeb, remoteUserDB, spec, authMethod,
	// hostIdent, prefix, logAll, logCommands, logConvo,
	// logErrors, logAuth, logDebug, modules
}

function bubblesTo(obj,key){
	//NOTE: This could throw an exception if you don't pass a settings object
	// I don't care about you if you're that stupid
	while(key in obj && obj.__lookupGetter__(key)){
		obj = obj._parent;
	}
	return obj;
}

function loadFile(file){
	fs.readFile(file,function(err,data){
		if(err)throw err;
		var root = jslon.parse(data);
		//Lowest children are most important
		//Trace heirarchy backwards to bubble up
		settings = [];
		function recurse(x,nom){
			x._name = nom;
			if("$" in x){
				x.$._parent = x;
				for(var i in x.$){
					var child = x.$[i];
					for(var j in x){
						//Add a bubbler for attributes the parent has
						// but the child doesn't
						if(j.charAt(0) != "_" && !(j in child)){
							child.__defineGetter__(j,_getParentProp(j));
							child.__defineSetter__(j,_setSelf(j));
						}
					}
					recurse(child,i);
				}
			} else {
				settings.push(x);
			}
		}
		recurse(root,"root");
	});
}

function load(){
	//TODO: Load from database
}

//TODO: Save functions

module.exports = {
	bubblesTo: bubblesTo,
	loadFile: loadFile,
}
