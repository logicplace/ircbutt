/*
Describe messages sent by the server and how to read them
:sender command params\r\n
command is the key, params described in the value (bounds are implied)
Everything's literally matched except:
{name} matches a value potentially with spaces and saves to name (.*)
{name:N} same as above, but may only contain up to N spaces
{name=N} same as above, but must contain exactly N spaces
<name> matches a value without spaces and saves to name ([^ ]*)
<name:etc> same as above, but characters in etc are also not allowed
+Note that to use a literal - instead of a range, use --
<name=etc> match a value that only contains etc. Put a + on the end
+to match multiple of those characters.
<name!etc> same as above but negative.
<#name> matches number and saves to name ([0-9]+)
<#name:.,> matches number with given modifiers ([0-9,]+(\.[0-9]+)?)
+Put an s on the end to switch the meaning of . and ,
<name@otherName> inherets the match rules of otherName. Preceding
+otherName with a _ references the global rule, otherwise references
+one in the current message.
/name:regex/ specific match (grouping is implied) note: regex is JS's
suffixing with a * (ie. directly after } > or /) will cause the same
+thing to match multiple times and return an array under that name
escape {}<>/%* by preceeding it with a %
Can be an array for multiple forms.
Sections with the same name will assert equivalence within that key
You may denote a section with ()
Sections surrounded by [] denote optional sections.
If there are multiple options per section use [grp1]|[grp2]
If they're not optional, use (grp1)|(grp2)
For all groups - {} <> // () [] - you may start it with one character
+followed by a | to denote what the separator is between multiple
+instances of this section. By default it's space
*/

/*
Message Object {
	sc: SERVER | CLIENT, //sent from Server and/or Client
	//Can be arrays
	msg: "", //Message passed to splitter, default
	rsp: [], //Possible response commands, default
	//The below can also be strings, assumed to be msg
	rfc1459 { //only using rfc1459 (this before default)
		msg: "",
		rsp: [],
	},
	rfc281x: { //with rfc2810-rfc2813 enabled
		msg: "",
		rsp: [],
	},
}
*/

var Splitter = require("./splitter.js");

var SERVER=1,CLIENT=2,INTERSERVER=4,msgs;

function splitWholeEntries(len,data){
	var ret=[];
	while(data.length){
		var rlen = -1;
		for(var i=0;i<data.length && (rlen+=(data[i].length+1)) <= len;++i);
		if(i == 0)
		ret.push(data.slice(0,i));
		data = data.slice(i);
	}
	return ret;
}

function splitFormattedText(len,data){
	var ret = [];
	while(data.length){
		//Make sure to carry over formatting and CTCPs if they can't be completed on that line
		//Word wrap, as well
		//Reference: CTCP \1, Bold \2, Color \3, Italic/Reversed \26, Underline \37, Unformat \17
		var rstr = data.substr(0,len)
		,   rmdr = data.substr(len)
		,   pos,fmt;
		if(rstr.match(/\1/g).length % 2 == 1){
			//CTCP was cut off
			pos = rstr.lastIndexOf("\1");
			rmdr = rstr.substr(pos)+rmdr;
			rstr = rstr.substr(0,pos);
		}
		//Split to last bound (if it's not too far)
		var tmp;
		if(tmp=rstr.match(/(.*[^a-zA-Z0-9\1\2\3\26\37\17].*?)([^\1]*)$/) 
		&& tmp[2].length < 20 && !rmdr.match(/^[^a-zA-Z0-9\1\2\3\26\37\17]/)){
			rstr = tmp[1];
			rmdr = tmp[2]+rmdr;
		}
		fmt = rstr.match(/[\2\3\26\37\17]/g);
		if((pos = fmt.lastIndexOf("\17")) != -1){
			//Stopper was found, only retain what comes after
			fmt.slice(pos+1);
		}
		if(fmt.length){
			//Formatting left over, prepend to remainder
			rmdr = fmt.join("")+rmdr;
		}
	
		ret.push(rstr)
		data = rmdr;
	}
	return ret;
}

module.exports = msgs = {
	"_server": ":<sender> <command> {args}",
	"_client": "<command> {args}",
	//"_args": "<spaced>* :{trailing}",
	"_target": "(,|"+
		"(/prefix:[#+&]|![A-Z0-9]{5}/<channel:\0\7\r\n,:>[:<mask@channel>])|"+
		"(<user>[%<host>]@<server>)|"+
		"(<user>%<host>)|"+
		"(<nick>[!<user>@<host>])|"+
		//"([$#]"
	")*",
	"_hostname": "<,|@_shortname>*",
	"_shortname": "/:[a-zA-Z0-9][a-zA-Z0-9--][a-zA-Z0-9]/",
	"001": {
		sc: SERVER,
		msg: "<nick> :Welcome to the {network} <nick>!<user>@<host>",
	},
	"002": {
		sc: SERVER,
		msg: "<nick> :Your host is <serverName>, running version <version>",
	},
	"003": {
		sc: SERVER,
		msg: "<nick> :This server was created {date}",
	},
	"004": {
		sc: SERVER,
		msg: "<nick> <serverName> <version> <okUserModes> <okChannelModes>",
	},
	"005": [{
		sc: SERVER,
		msg: "<nick> <support>* :are supported by this server", //Sent at the start
		split: ["support",splitWholeEntries],
	},{
		sc: SERVER,
		msg: "<nick> :Try server <server>, port <#port>", //RPL_BOUNCE (RFC2812)
	}],
	"251": {
		sc: SERVER,
		msg: "<nick> :There are <#userC> users and <#invisC> invisible on <#servC> servers",
	},
	"252": {
		sc: SERVER,
		msg: "<nick> <#opsC> :operator(s) online",
	},
	"254": {
		sc: SERVER,
		msg: "<nick> <#chanC> :channels formed",
	},
	"353": {
		sc: SERVER,
		msg: "<channel> :<nicks>*",
	},
	"376": {
		sc: SERVER,
		msg: ":End of /MOTD command",
	},
	"422": {
		sc: SERVER,
		msg: ":MOTD File is missing",
	},
	"433": {
		sc: SERVER,
		msg: "<nick> :Nickname is already in use",
	}
	
	"JOIN": {
		sc: SERVER|CLIENT,
		msg: "<,|channel>* <,|key>*",
		rsp: [
			//... a lot
		],
	},
	"KICK": {
		sc: SERVER|CLIENT,
		msg: [
			"<channel> <user>",
			"<channel> <user> :<comment>",
		],
		rsp: [
		],
	},
	"MODE": {
		sc: SERVER|CLIENT,
		//Argument order is limit, users, ban masks
		msg: "<channel> /modes:[+\\-][^ ]+/ <args>*",
		rsp: [
		],
	},
	"NICK": {
		sc: SERVER|CLIENT,
		msg: ["<nickname>","<nickname> <hopcount>"],
		split: ["support",splitWholeEntries]
		rsp: ["431","432","433","436"],
	},
	"NOTICE": {
		sc: SERVER|CLIENT,
		msg: "<target> :{text}",
		split: ["text",splitFormattedText],
	},
	"OPER": {
		sc: CLIENT,
		msg: "<name> <password>",
	},
	"PART": {
		sc: CLIENT|SERVER,
		msg: "<,|channel>*"
	}
	"PASS": {
		sc: CLIENT,
		msg: "<password>",
		rsp: ["461","462"],
	},
	"PING": {
		sc: SERVER|CLIENT
		msg: "<server1> <server2>"
		rsp: ["PONG",//...
		],
	},
	"PONG": {
		sc: SERVER|CLIENT
		msg: "<daemon1> <daemon2>"
		rsp: [
		],
	},
	"PRIVMSG": {
		sc: SERVER|CLIENT,
		msg: "<target> :{text}",
		split: ["text",splitFormattedText],
	},
	"QUIT": {
		sc: SERVER|CLIENT,
		msg: ":<message>",
	},
	"USER": {
		sc: CLIENT,
		rfc1459: "<username> <hostname> <servername> <realname>"
		rfc281x: "<username> <mode> * :{realname}",
		rsp: ["461","462"],
	},
}

//Make all splitters
for(var x in msgs){
	var msg = msgs[x];
	if(Array.isArray(msg)){
		for(var i=0;i<msg.length;++i){
			makeSplitter(msg,i,x.charAt(0) == "_");
		}
	} else makeSplitter(msgs,x,x.charAt(0) == "_");
}

function makeSplitter(msgs,x,mode){
	var msg = msgs[x];
	if(mode){
		msgs[x] = new Splitter(msg);
	} else {
		if("msg" in msg){
			msg.msg = new Splitter(msg.msg);
		}
		for(var i=0;i<2;i++){
			var rfc = i==0?"rfc1459":"rfc281x";
			if(rfc in msg){
				if(typeof(msg[rfc]) == "string"){
					msg[rfc] = {
						msg: new Splitter(msg[rfc]);
					}
				} else if("msg" in msg[rfc]) {
					msg[rfc].msg = new Splitter(msg[rfc].msg);
				}
			}
			if(!("split" in msg)){
				msg.split = null;
			}
		}
	}
}
