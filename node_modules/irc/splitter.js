var
	Class = require("class")
	,exception = require("exception")
	,comp = require("comp")
;

/** EXCEPTIONS **/
function AssertionFailed(expected,got,position){exception(this)}
function UnmatchedBracket(brackets,position){exception(this)}

/** Shorthand Funcs **/
function limSplit(str,spl,lim,returnDelims){
	//Unlike default limited split because it retains the trailing pieces
	if(typeof(returnDelims) == "undefined")returnDelims=false;
	if(!Array.isArray(spl))spl = [spl];
	var find = new RegExp("["+escapeRE4Set(spl.join(""))+"]"),ret=[],m;
	for(var i=0;(m=str.match(find)) && i < lim;++i){
		ret.push(str.substr(0,m.index));
		if(returnDelims)ret.push(m[0]);
		str = str.substr(m.index);
	}
	if(str)ret.push(str);
	return ret;
	/*
	var arr = str.split(spl);
	if(arr.length <= lim+1)return arr;
	return arr.slice(0,lim).concat(arr.slice(lim).join(spl));
	*/
}

/**
* Escape for RegEx functions
**/
function escapeRE4Set(set,allDash){
	var tmp = /--/g; //-- is literal -, - is range
	if(1 in arguments)tmp = /-/g; //Escape all -
	return set
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]])/g,"\\$1")
		.replace(tmp,"\\-")
	;
}

function escapeRE(str){
	return str
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]{}()^$+*.?|])/g,"\\$1")
	;
}

/** HELPER FUNCTIONS **/
function applySplitter_findEnd(spltr,i,find){
	var end=i,mod="",xtra=0,str,pre="";
	//Find the ending bracket (next unescaped bracket)
	while((end=spltr.indexOf(find,end+1)) >= 0
	&& spltr.charAt(end-1) == "%");
	
	//None was found
	if(end == -1) throw new UnmatchedBracket(spltr.charAt(i)+find,i);
	
	//Check for modifiers
	/*switch(spltr.charAt(end+1)) //For if more than one are added*/
	if(spltr.charAt(end+1) == "*"){
		mod = "*"; ++xtra;
	}
	
	//Split out prepender
	str = spltr.slice(i+1,end);
	if(str.charAt(1) == "|" && str.charAt(0) != "%"){
		pre = str.charAt(0);
		str = str.slice(2);
	}
	
	//Return contents without %s or brackets
	return [str.replace(/%(.)/g,"$1"),mod,end+xtra,pre];
}

function fashionTokenRE(token,subGroups){
	var theGrp = token[0],ctoken,theOptions,mod,subGrp
	,pre,tore,re="",grpIdx = 1,sgi=0,groups={};
	for(var ch=0;ch<theGrp.length;++ch){
		if(ch%2 == 0){
			re += escapeRE(theGrp[ch]);
		} else {
			theOptions = theGrp[ch];
			var optsExist=(theOptions.length!=1),tmpre = "";
			if(optsExist){
				tmpre = "(";
				++grpIdx;
			}
			for(var ori=0;ori<theOptions.length;++ori){
				ctoken = theOptions[ori];
				tore = ctoken[1];
				mod = ctoken[2];
				pre = ctoken[4];
				if(mod.indexOf("*") != -1)tore = "("+tore+"("+pre+tore+")*)";
				else tore = "("+tore+")";
				if(mod.indexOf("?") != -1)tore += "?";
				//Merge subGroups info into groups
				if(Array.isArray(ctoken[0])){
					subGrp = subGroups[sgi++];
					for(var i in subGrp){
						groups[grpIdx+parseInt(i)] = subGrp[i];
					}
				} else {
					groups[grpIdx] = ctoken;
				}
				//Number of unescaped ( in tore
				grpIdx += ((" "+tore).match(/[^\\](?=\()/g) || []).length;
				tmpre += tore+"|";
			}
			re += tmpre.slice(0,-1);
			if(optsExist)re += ")";
		}
	}
	
	token[1] = re;
	return groups;
}

module.exports = Class({
	//Split expression and store comprehension
	//XXX(Posibility): Compile comprehension into a function to form things
	name: "Splitter",
	//TODO: Add case insensitivity argument
	init: function(spl){
		this.source = spl;
		this.tokens = [""];
		this.regex = /$^/;
		this.groups = {};
		
		var len = spl.length,tidx=0,re="",nom,tore,mod,ni,pre
		,lastWasGrp=false,current=this.tokens,parents=[],wasgrp,orArray=null
		,subGroups=[[]];
		for(i=0;i<len;++i){
			c = spl.charAt(i);
			nom = ""; tore = ""; ni = i; wasgrp = false;
			switch(c){
				case "<": { //Spaceless group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,">");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					//Number form
					if(grp.charAt(0) == "#"){
						var num = grp.slice(1).split(":");
						nom = num[0];
						if(num.length == 1)tore = "[0-9]+";
						else switch(num[1]){
							case ".": tore = "[0-9]+(\.[0-9]+)?"; break;
							case ".s": tore = "[0-9.]+"; break;
							case ",": tore = "[0-9,]+"; break;
							case ",s": tore = "[0-9]+(,[0-9]+)?"; break;
							case ".,": case ",.": tore = "[0-9,]+(\.[0-9]+)?"; break;
							case ".,s": case ",.s": tore = "[0-9.]+(,[0-9]+)?"; break;
							default: throw new AssertionFailed("/[.,]{1,2}s?/",num[1],i);
						}
					//Regular form
					} else {
						var pt = limSplit(grp,[":","=","!"],1,true);
						nom = pt[0];
						if(pt.length == 1){
							tore = "[^ "+pre+"]+";
						} else switch(pt[1]){
							case ":": {
								tore = "[^ "+pre+escapeRE4Set(pt[2])+"]+";
								break;
							} case "=": {
								if(pt[2].slice(-1) == "+"){
									tore = "["+escapeRE4Set(pt[2]).slice(0,-1)+"]+";
								} else {
									tore = "["+escapeRE4Set(pt[2])+"]";
								}
							} case "!": {
								tore = "[^"+(pre?pre:" ");
								if(pt[2].slice(-1) == "+"){
									tore += escapeRE4Set(pt[2]).slice(0,-1)+"]+";
								} else {
									tore += escapeRE4Set(pt[2])+"]";
								}
							}
						}
						if(pre=="")pre = " ";
					}
					break;
				} case "{": { //Spaced group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,"}"),tm;
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					//Limited spaces versions
					if(tm = grp.match(/([^:=]+)([:=])([0-9]+)/)){
						nom = tm[1];
						if(pre=="")pre = " ";
						switch(tm[2]){
							case ":": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){1,"+tm[3]+"}"; break;
							case "=": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){"+tm[3]+"}"; break;
						}
					} else if(grp.search(/[:=]/) >= 0) {
						throw new AssertionFailed("Number for argument",
							grp.slice(grp.search(/[:=]/)+1),i
						);
					} else {
						nom = grp;
						if(pre != "")tore = "[^"+pre+"]+";
						else tore = ".+"
					}
					break;
				} case "/": { //Specific group
					lastWasGrp = true;
					var grp = applySplitter_findEnd(spl,i,"/");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]||" "; grp=grp[0];
					var pt = limSplit(grp,":",1);
					if(pt.length != 2){
						throw new AssertionFailed(
							"This form requires an argument","No argument",i
						);
					}
					nom = pt[0];
					tore = pt[1];
					break;
				} case "(": { //Group
					lastWasGrp = false;
					wasgrp = true; mod = "";
					break;
				} case "[": { //Optional group
					lastWasGrp = false;
					wasgrp = true; mod = "?";
					break;
				} case ")": { //Group end
					//fall through
				} case "]": { //Optional group end
					lastWasGrp = true;
					current = parents.pop();
					tidx = current.length-1;
					//Fix mod if there's a * next
					var thatGrp=current[tidx-1].slice(-1)[0];
					if(spl.charAt(i+1) == "*"){
						ni = ++i;
						thatGrp[2] += "*";
					}
					//Combobulate tore
					subGroups[parents.length].push(fashionTokenRE(thatGrp,
						subGroups[parents.length+1]
					));
					break;
				} case "%": { //Literal
					lastWasGrp = false;
					c = spl.charAt(ni=++i);
					//fall through
				} case "|": { //Multiple options if between groups
					if(lastWasGrp){
						lastWasGrp = false;
						orArray = current[tidx-1];
						break;
					}
					//fall through
				} default: {
					if(orArray)throw new AssertionFailed(
						"Or operator requires a group directly after it.","No group",i
					);
					lastWasGrp = false;
					current[tidx] += c; 
					//re += escapeRE(c);
					break;
				}
			}
			if(wasgrp){
				//Find pre
				if(spl.charAt(i+2) == "|"){
					pre = spl.charAt(i+1);
					ni = i+2;
				} else {
					pre = " ";
				}
				var group = [""]
				,token = [group,"",mod,i,pre];
				if(orArray){
					orArray.push(token)
					orArray = null;
				} else {
					current.push([token]);
					current.push("");
				}
				if(subGroups.length-1 <= parents.length){
					subGroups.push([]);
				}
				parents.push(current);
				current = group;
				tidx = 0;
			}
			else if(nom != ""){
				var token = [nom,tore,mod,i,pre];
				if(orArray){
					orArray.push(token);
					orArray = null;
				} else {
					current.push([token]);
					current.push("");
				}
				tidx += 2;
				//re += tore;
			}
			i = ni;
		}
		if(parents.length){
			throw new UnmatchedBracket(
				"])",i
			);
		}
		var tmpToken = [this.tokens,"","",0," "];
		this.groups = fashionTokenRE(tmpToken,subGroups[0]);
		//console.log(tmpToken[1]);
		this.regex = new RegExp("^"+tmpToken[1]+"$");
	},
	
	//TODO: Make the writable version recursive. Return should be by the top level.
	//ie. "<abc>( <deep> <er>) <harrrr>" if deep and er don't exist, but abc and
	//harrrr do, -1 is returned, because one group is missing.
	_matches: function(data,tokens,haso){
		var missing=0;
		for(var i=1;i<tokens.length;i+=2){
			var opts = tokens[i],optional=0;
			for(var j=0;j<opts.length;++j){
				nn=opts[j][0];
				if(Array.isArray(nn)){
					var tmp = this._matches(data,nn,haso);
					if(tmp < 0){
						if(opts[j][2].indexOf("?") != -1) {
							++optional;
						}
					} else {
						break;
					}
				}
				else if(nn in data){
					haso[nn] = 1;
					break;
				}
			}
			if(j == opts.length && optional != j)++missing;
		}
		return -missing;
	},
	matches: function(x){
		if(typeof(x) == "string")return !!x.match(this.regex)
		else{
			//Check content of x (object) against the tokens
			//+list (this.tokens[i%2][0]).
			//Return: 0 for exact match, positive for more than needed,
			//+negative for less than needed. If there is both more and
			//+less, less is returned.
			var haso={},added=0
			,missing = this._matches(x,this.tokens,haso);
			for(var y in x){
				if(!(y in haso))added++;
			}
			return (missing?missing:added);
		}
	},
	
	read: function(msg){
		var m = msg.match(this.regex),ret={};
		if(!m)return null;
		//console.log("Matched ok");
		for(i=0;i<m.length;i++){
			//Is this named?
			if(i in this.groups){
				//console.log(i+" in groups.");
				var nom = this.groups[i][0]
				,   mod = this.groups[i][2]
				,   re
				,   pos = this.groups[i][3]
				,   pre = this.groups[i][4]
				,   res = m[i]
				;///var
				if(mod.indexOf("*") != -1) {
					var arr = [],tmp;
					re = new RegExp("^("+this.groups[i][1]+")("+pre+"|$)");
					while((tmp = res.match(re)) && tmp[0].length){
						arr.push(tmp[1]);
						res = res.slice(tmp[0].length);
					}
					res = arr;
				}
				//console.log(nom+":"+res);
				if(typeof(res) != "undefined"){
					if(nom in ret && !comp(ret[nom],res)){
						throw new AssertionFailed(ret[nom],res,pos);
					}
					ret[nom] = res;
				}
			}
		}
		return ret;
	},
	
	_write: function(data,except,tokens){
		var ret = "",i,j,k;
		for(i=0;i<tokens.length;++i){
			//Literal
			if(i%2 == 0){
				//console.log("Writing: '"+tokens[i]+"'");
				ret += tokens[i];
			} else {
				//Group
				var opts = tokens[i],optional=0;
				//console.log("Enumerating "+opts.length+" options.");
				for(j=0;j<opts.length;++j){
					var tk = opts[j];
					if(Array.isArray(tk[0])){
						//() or []
						//console.log("Was group.");
						var tmp = this._write(data,except,tk[0]);
						if(tmp){
							ret += tmp;
							break;
						} else if(tk[2].indexOf("?") != -1) {
							++optional;
						}
					} else {
						//Other group
						//console.log("Was token: "+tk[0]);
						if(tk[0] in except)break;
						if(tk[0] in data){
							//console.log("Exists in data");
							var d = data[tk[0]];
							if(typeof(d) == "string")d = [d];
							for(k=0;k<d.length;++k){
								if(!d[k].match("^("+tk[1]+")$")){
									throw new AssertionFailed(tk[1],d[k],tk[3]);
								}
							}
							if(tk[2])d = d.join(tk[4]);
							else d = d[0];
							//console.log("Final data looks like: '"+d+"'");
							ret += d;
							break;
						} //NOTE: If ? is ever added to tokens,
						// this is where the check goes.
					}
				}
				if(j == opts.length && optional != j)return "";
			}
		}
		return ret;
	},
	
	write: function(data,except){
		var tmp={};
		if(Array.isArray(except)){
			for(var i=0;i<except.length;++i){
				tmp[except[i]] = true;
			}
		} else if(typeof(except) == "string") {
			tmp[except] = true;
		}
		return this._write(data,tmp,this.tokens);
	},
	
/*	write: function(data,except){
		var ret = "",ttlRet="",i,j;
		this.tempTokens = [];
		if(!(1 in arguments))except = "";
		for(i=0;i<this.tokens.length;++i){
			if(i%2 == 0)ret += this.tokens[i];
			else {
				var tk = this.tokens[i],br = false;
				if(tk[0] == except){
					ttlRet += ret;
					this.tempTokens.push(ret);
					this.tempTokens.push(tk);
					ret = "";
					br = true;
				}
				if(br)continue;
				if(tk[0] in data){
					var d = data[tk[0]];
					if(typeof(d) == "string")d = [d];
					for(j=0;j<d.length;++j){
						if(!d[j].match("^("+tk[1]+")$")){
							throw new AssertionFailed(tk[1],d[j],tk[3]);
						}
					}
					if(tk[2])d = d.join(tk[4]);
					else d = d[0];
					ret += d;
				}
			}
		}
		return ttlRet+ret;
	},
	
	finishWrite: function(data){
		var temp = this.tokens;
		this.tokens = this.tempTokens;
		var ret = this.write(data);
		this.tokens = temp;
		return ret;
	}*/
})
