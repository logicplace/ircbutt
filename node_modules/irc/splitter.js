var
	Class = require("class")
	,exception = require("exception")
	,comp = require("comp")
;

/** EXCEPTIONS **/
function AssertionFailed(expected,got,position){exception(this)}
function UnmatchedBracket(brackets,position){exception(this)}

/** Shorthand Funcs **/
function limSplit(str,spl,lim){
	//Unlike default limited split because it retains the trailing pieces
	var arr = str.split(spl);
	if(arr.length <= lim+1)return arr;
	return arr.slice(0,lim).concat(arr.slice(lim).join(spl));
}

/**
* Escape for RegEx functions
**/
function escapeRE4Set(set,allDash){
	var tmp = /--/g; //-- is literal -, - is range
	if(1 in arguments)tmp = /-/g; //Escape all -
	return set
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]])/g,"\\$1")
		.replace(tmp,"\\-")
	;
}

function escapeRE(str){
	return str
		.replace(/\\/g,"\\\\")
		.replace(/([\[\]{}()^$+*.?|])/g,"\\$1")
	;
}

/** HELPER FUNCTIONS **/
function applySplitter_findEnd(spltr,i,find){
	var end=i,mod="",xtra=0,str,pre="";
	//Find the ending bracket (next unescaped bracket)
	while((end=spltr.indexOf(find,end+1)) >= 0
	&& spltr.charAt(end-1) == "%");
	
	//None was found
	if(end == -1) throw new UnmatchedBracket(spltr.charAt(i)+find,i);
	
	//Check for modifiers
	/*switch(spltr.charAt(end+1)) //For if more than one are added*/
	if(spltr.charAt(end+1) == "*"){
		mod = "*"; ++xtra;
	}
	
	//Split out prepender
	str = spltr.slice(i+1,end);
	if(str.charAt(1) == "|" && str.charAt(0) != "%"){
		pre = str.charAt(0);
		str = str.slice(2);
	}
	
	//Return contents without %s or brackets
	return [str.replace(/%(.)/g,"$1"),mod,end+xtra,pre];
}

//TODO: Optional sections via [] (make everything else required)
module.exports = Class({
	//Split expression and store comprehension
	//XXX: Compile comprehension into a function to form things
	name: "Splitter",
	init: function(spl){
		this.source = spl;
		this.tokens = [""];
		this.regex = /$^/;
		this.groups = {};
		
		var len = spl.length,tidx=0,re="",tore,mod,ni,pre,grpIdx=1;
		for(i=0;i<len;++i){
			c = spl.charAt(i);
			nom = ""; tore = ""; ni = i;
			switch(c){
				case "<": { //Spaceless group
					var grp = applySplitter_findEnd(spl,i,">");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					//Number form
					if(grp.charAt(0) == "#"){
						var num = grp.slice(1).split(":");
						nom = num[0];
						if(num.length == 1)tore = "[0-9]+";
						else switch(num[1]){
							case ".": tore = "[0-9]+(\.[0-9]+)?"; break;
							case ".s": tore = "[0-9.]+"; break;
							case ",": tore = "[0-9,]+"; break;
							case ",s": tore = "[0-9]+(,[0-9]+)?"; break;
							case ".,": case ",.": tore = "[0-9,]+(\.[0-9]+)?"; break;
							case ".,s": case ",.s": tore = "[0-9.]+(,[0-9]+)?"; break;
							default: throw new AssertionFailed("/[.,]{1,2}s?/",num[1],i);
						}
					//Regular form
					} else {
						var pt = limSplit(grp,":",1);
						nom = pt[0];
						if(pt.length == 1)tore = "[^ "+pre+"]+";
						else tore = "[^ "+pre+escapeRE4Set(pt[1])+"]+";
						if(pre=="")pre = " ";
					}
					break;
				} case "{": { //Spaced group
					var grp = applySplitter_findEnd(spl,i,"}"),tm;
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]; grp=grp[0];
					//Limited spaces versions
					if(tm = grp.match(/([^:=]+)([:=])([0-9]+)/)){
						nom = tm[1];
						if(pre=="")pre = " ";
						switch(tm[2]){
							case ":": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){1,"+tm[3]+"}"; break;
							case "=": tore = "[^"+pre+"]+("+pre+"[^"+pre+"]+){"+tm[3]+"}"; break;
						}
					} else if(grp.search(/[:=]/) >= 0) {
						throw new AssertionFailed("Number for argument",
							grp.slice(grp.search(/[:=]/)+1),i
						);
					} else {
						nom = grp;
						if(pre != "")tore = "[^"+pre+"]+"
						else tore = ".+"
					}
					break;
				} case "/": { //Specific group
					var grp = applySplitter_findEnd(spl,i,"/");
					//console.log(grp);
					mod=grp[1]; ni=grp[2]; pre=grp[3]||" "; grp=grp[0];
					var pt = limSplit(grp,":",1);
					if(pt.length != 2){
						throw new AssertionFailed(
							"This form requires an argument","No argument",i
						);
					}
					nom = pt[0];
					tore = pt[1];
					break;
				} case "%": { //Literal
					c = spl.charAt(ni=++i);
					//fall through
				} default: {
					this.tokens[tidx] += c; 
					re += escapeRE(c);
					break;
				}
			}
			if(nom != ""){
				var token = [nom,tore,mod,i,pre];
				this.tokens.push(token);
				this.tokens.push("");
				tidx += 2;
				this.groups[grpIdx]=token;
				//Number of unescaped ( in tore
				//if(mod == "*")tore = "(((^|"+pre+")"+tore+")*)";
				if(mod == "*")tore = "("+tore+"("+pre+tore+")*)";
				else tore = "("+tore+")";
				grpIdx += ((" "+tore).match(/[^\\](?=\()/g) || []).length;
				re += tore;
			}
			i = ni;
		}
		this.regex = new RegExp("^"+re+"$");
	},
	
	read: function(msg){
		var m = msg.match(this.regex),ret={};
		if(!m)return null;
		for(i=0;i<m.length;i++){
			//Is this named?
			if(i in this.groups){
				var nom = this.groups[i][0]
				,   mod = this.groups[i][2]
				,   re
				,   pos = this.groups[i][3]
				,   pre = this.groups[i][4]
				,   res = m[i]
				;///var
				if(mod) {
					var arr = [],tmp;
					//TODO: May need an adjustment in regards to pre
					re = new RegExp("^("+this.groups[i][1]+")("+pre+"|$)");
					//TODO: Split properly
					while((tmp = res.match(re)) && tmp[0].length){
						arr.push(tmp[1]);
						res = res.slice(tmp[0].length);
					}
					res = arr;
				}
			
				if(nom in ret && !comp(ret[nom],res)){
					throw new AssertionFailed(ret[nom],res,pos);
				}
				ret[nom] = res;
			}
		}
		return ret;
	},
	
	//TODO: Reduce excess spaces?
	write: function(data,except){
		var ret = "",ttlRet="",i,j;
		this.tempTokens = [];
		if(!(1 in arguments))except = "";
		for(i=0;i<this.tokens.length;++i){
			if(i%2 == 0)ret += this.tokens[i];
			else {
				var tk = this.tokens[i],br = false;
				if(tk[0] == except){
					ttlRet += ret;
					this.tempTokens.push(ret);
					this.tempTokens.push(tk);
					ret = "";
					br = true;
				}
				if(br)continue;
				if(tk[0] in data){
					var d = data[tk[0]];
					if(typeof(d) == "string")d = [d];
					for(j=0;j<d.length;++j){
						if(!d[j].match("^("+tk[1]+")$")){
							throw new AssertionFailed(tk[1],d[j],tk[3]);
						}
					}
					if(tk[2])d = d.join(tk[4]);
					else d = d[0];
					ret += d;
				}
			}
		}
		return ttlRet+ret;
	},
	
	finishWrite: function(data){
		var temp = this.tokens;
		this.tokens = this.tempTokens;
		this.write(data);
		this.tokens = temp;
	}
})
