var
	Class = require("class")
	,proto = require("./proto.js")
	//,settings = require("./settings.js")
;

function dispatchEvents(events,base,context){
	//Each event has 5 priority levels	
	if(!(base.command in events))return false;
	var event = events[base.command],ret,ep; //Event[Priority]
	if(base.command in proto){
		var proCom = proto[base.command],msg;
		if("msg" in proCom)msg = proCom.msg;
		else if(context.spec in proCom && "msg" in proCom[context.spec]){
			msg = proCom[context.spec].msg;
		}
		base.args = msg.read(base.args);
	}
	for(var p=0;p<5;++p){ //Priority
		ep = event[p];
		for(var i=0;i<ep.length;++i){
			//NOTE: If a module changes this (base.args) it changes it
			//+for subsequent modules. Is this bad?
			ep[i][1](base.args);
		}
	}
}

module.exports = Class({
	init: function(context){
		this.settings = context;
		this.sesKnow = { //Session Knowledge
			serverID = 0,
			connected = false,
			flood = 0,
		};
		this.events = {};
	},
	
	connect: function(){
		this.server = false;
		(this.conn = new net.Socket())
		.on("connect",this.onConnect)
		.connect(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID]
		)
		;
	},
	
	host: function(){
		this.server = true;
		(this.conn = net.createServer(this.onConnect))
		.on("error",this.onError)
		.listen(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID],this.onSuccess
		)
		;
		//Each connection will have its own buffers
	},
	
	onSuccess: function(){
		this.sesKnow.connected = true;
		this.sesKnow.host = this.settings.host[sesKnow.serverID];
		this.sesKnow.ports = this.settings.port[sesKnow.serverID];
	}
	
	restart: function(){
		if(server){
			this.conn.close();
			this.host();
		} else {
			this.conn.end();
			this.connect();
		}
	},
	
	on: function(modName,event,priority,handler){
		if(argumets.length == 2){
			handler = priority;
			priority = 2;
		}
		if(event in proto && event.charAt(0) != "_"){
			if(event in this.events){
				this.events[event][priority].push([modName,handler]);
			} else {
				//Create five priorities
				this.events[event] = [[],[],[],[],[]];
			}
		}
	},
	
	//Socket commands
	send: function(command,data,priority){
		if(command in proto){
			var proCom = proto[base.command],msg;
			//TODO: proCom can be an array, accomodate
			if("msg" in proCom)msg = proCom.msg;
			else if(this.settings.spec in proCom && "msg" in proCom[this.settings.spec]){
				msg = proCom[this.settings.spec].msg;
			}
			var mode = this.server?"_server":"_client";
			//Split by settings (context aware)
			// 1) Check length of the unsplitable parts of the messages
			// 2) Pass available length to handler function
			if("split" in proCom){
				var except = proCom.split[0]
				,arg = msg.write(data,except)
				,len = proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: arg
				}.length;
				data[except] = proCom.split[1](
					this.settings.flood.chars[this.sesKnow.flood]-len,
					data[except]
				);
				
				return this.sendRaw(proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.finishWrite(data)
				}),priority);
			} else {
				return this.sendRaw(proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.write(data)
				}).substr(0,this.settings.flood.chars[this.sesKnow.flood])
				,priority);
			}
		}
		return false
	},
	
	sendRaw: function(str,priority){
		//TODO: Ensure this is below max length
		if(typeof(priority) == "undefined")priority = 2;
		this.writeBuffer[priority].push(str);
	},
	
	//Socket events
	onConnect: function(sock){
		if(!server){
			sock = this.conn;
			this.onSuccess();
		}
		sock.on("data",this.onData);
		sock.on("end",this.onEnd);
		sock.on("timeout",this.onTimeout);
		sock.on("drain",this.onDrain);
		sock.on("error",this.onError);
		sock.on("close",this.onClose);
		
		sock.readBuffer = "";
		sock.writeBuffer = [[],[],[],[],[]];
	},
	
	onData: function(data){
		data = (this.readBuffer+data).split("\r\n");
		this.readBuffer = data.pop();
		var mode = this.server?"_client":"_server";
		for(var i=0;i<data.length;++i){
			var base = proto[mode].read(data[i]);
			if(base == null)continue; //Error stuff
			//var args = proto._args.read(base.args);
			dispatchEvents(this.events,base,this.settings);
		}
	},
	
	onEnd: function(){
	},
	
	onTimeout: function(){
		//TODO: Restart I guess?
	},
	
	onDrain: function(){
	},
	
	onError: function(error){
		this.closedByError = true; //To know to restart
		switch(e.code){
			case "EADDRINUSE": case "ECONNREFUSED": {
				if(e.code == "EADDRINUSE"){
					console.log("ERROR: Address in use, trying next in sequence...");
				} else {
					console.log("ERROR: Connection refused, trying next in sequence...");
				}
				//Increase and loop serverID as necessary
				if(++this.sesKnow.serverID >= this.settings.port.length){
					this.sesKnow.serverID = 0;
				}
				setTimeout(this.restart,1000);
			}
		}
	},
	
	onClose: function(hadError){
		if("closedByError" in this){
			delete this.closedByError;
			this.restart();
		}
	},
});
