var
	Class = require("class")
	,proto = require("./proto.js")
	//,settings = require("./settings.js")
;

function dispatchEvents(events,base,context){
	//Each event has 5 priority levels	
	if(!(base.command in events))return false;
	var event = events[base.command],ret,ep; //Event[Priority]
	if(base.command in proto){
		var proCom = proto[base.command],msg;
		if("msg" in proCom)msg = proCom.msg;
		else if(context.spec in proCom && "msg" in proCom[context.spec]){
			msg = proCom[context.spec].msg;
		}
		base.args = msg.read(base.args);
	}
	for(var p=0;p<5;++p){ //Priority
		ep = event[p];
		for(var i=0;i<ep.length;++i){
			//NOTE: If a module changes this (base.args) it changes it
			//+for subsequent modules. Is this bad?
			ep[i][1](base.args);
		}
	}
}

function findMsg(proCom,spec){
	if("msg" in proCom)return proCom.msg;
	else if(spec in proCom && "msg" in proCom[spec]){
		return proCom[spec].msg;
	} else return null;
}

//TODO: Write buffer is per socket, refer to current socket
// with this.this
module.exports = Class({
	init: function(context){
		this.settings = context;
		this.sesKnow = { //Session Knowledge
			serverID = 0,
			connected = false,
			flood = 0,
			floodCnt = 0,
		};
		this.events = {};
		this.sender = null;
	},
	
	connect: function(){
		this.server = false;
		(this.conn = new net.Socket())
		.on("connect",this.onConnect)
		.connect(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID]
		)
		;
	},
	
	host: function(){
		this.server = true;
		(this.conn = net.createServer(this.onConnect))
		.on("error",this.onError)
		.listen(this.settings.port[sesKnow.serverID],
			this.settings.host[sesKnow.serverID],this.onSuccess
		)
		;
		//Each connection will have its own buffers
	},
	
	onSuccess: function(){
		this.sesKnow.connected = true;
		this.sesKnow.host = this.settings.host[sesKnow.serverID];
		this.sesKnow.ports = this.settings.port[sesKnow.serverID];
	}
	
	restart: function(){
		if(server){
			this.conn.close();
			this.host();
		} else {
			this.conn.end();
			this.connect();
		}
	},
	
	on: function(modName,event,priority,handler){
		if(argumets.length == 2){
			handler = priority;
			priority = 2;
		}
		if(event in proto && event.charAt(0) != "_"){
			if(event in this.events){
				this.events[event][priority].push([modName,handler]);
			} else {
				//Create five priorities
				this.events[event] = [[],[],[],[],[]];
			}
		}
	},
	
	//Socket commands
	send: function(command,data,priority){
		if(command in proto){
			var proCom = proto[base.command],msg;
			//TODO: Make this find the best match instead of last match
			if(Array.isArray(proCom)){
				for(var i=0;i<proCom.length;++i){
					if(msg=findMsg(proCom,this.settings.spec)
					&& msg.matches(data) < 0){
						msg=null;
					}
				}
				if(!msg){
					//TODO: Error?
					return false;
				}
			}
			else if(!(msg=findMsg(proCom,this.settings.spec))){
				//TODO: Error?
				return false;
			}
			var mode = this.server?"_server":"_client";
			//Split by settings (context aware)
			// 1) Check length of the unsplitable parts of the messages
			// 2) Pass available length to handler function
			if("split" in proCom){
				var except = proCom.split[0]
				,arg = msg.write(data,except)
				,len = proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: arg
				}.length;
				data[except] = proCom.split[1](
					this.settings.flood.chars[this.sesKnow.flood]-len,
					data[except]
				);
				
				return this.sendRaw(proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.finishWrite(data)
				}),priority);
			} else {
				return this.sendRaw(proto[mode].write({
					sender: this.sesKnow.host,
					command: command,
					args: msg.write(data)
				}))
				,priority);
			}
		}
		return false
	},
	
	sendRaw: function(str,priority){
		//Ensure this is below max length
		str = str.substr(0,this.settings.flood.chars[this.sesKnow.flood])
		if(typeof(priority) == "undefined")priority = 2;
		this.writeBuffer[priority].push(str);
		//Start send off if there isn't a queue
		if(!this.sender)this._send();
	},
	
	//Internal function that sends off the write queue
	_send: function(){
		//TODO: Lock this function so it can't be running
		//+multiple times in tandem?
		var len = this.settings.flood.amount;
		if(this.sesKnow.floodCnt >= len){
			this.sesKnow.flood = 1;
		}
		var fld = this.sesKnow.flood
		, wait = this.settings.flood.wait[fld]
		, tcwb = this.conn.writeBuffer
		,i=0,p,wb,l,wr="";
		//If amount is 0, send off all messages at once
		if(len == 0){
			len = this.writeBuffer[0].length
			+ this.writeBuffer[1].length
			+ this.writeBuffer[2].length
			+ this.writeBuffer[3].length
			+ this.writeBuffer[4].length;
		}
		for(p=0;p<5;++p){
			wb = this.writeBuffer[p];
			if(wait){
				if(wb.length)wr = wb.shift();
			} else {
				while(wb.length && i<len){
					wr += wb.shift();
					++i;
				}
			}
		}
		this.conn.write(wr);
		if(this.writeBuffer[0].length
			+ this.writeBuffer[1].length
			+ this.writeBuffer[2].length
			+ this.writeBuffer[3].length
			+ this.writeBuffer[4].length
		){
			this.sender = setTimeout(this._send,wait);
			this.sesKnow.floodCnt += 1;
		} else {
			this.sesKnow.flood = 0;
			this.sesKnow.floodCnt = 0;
		}
	},
	
	//Socket events
	onConnect: function(sock){
		if(!server){
			sock = this.conn;
			this.onSuccess();
		}
		sock.on("data",this.onData);
		sock.on("end",this.onEnd);
		sock.on("timeout",this.onTimeout);
		sock.on("drain",this.onDrain);
		sock.on("error",this.onError);
		sock.on("close",this.onClose);
		
		sock.readBuffer = "";
		sock.writeBuffer = [[],[],[],[],[]];
	},
	
	onData: function(data){
		data = (this.readBuffer+data).split("\r\n");
		this.readBuffer = data.pop();
		var mode = this.server?"_client":"_server";
		for(var i=0;i<data.length;++i){
			var base = proto[mode].read(data[i]);
			if(base == null)continue; //Error stuff
			//var args = proto._args.read(base.args);
			dispatchEvents(this.events,base,this.settings);
		}
	},
	
	onEnd: function(){
	},
	
	onTimeout: function(){
		//TODO: Restart I guess?
	},
	
	onDrain: function(){
	},
	
	onError: function(error){
		this.closedByError = true; //To know to restart
		switch(e.code){
			case "EADDRINUSE": case "ECONNREFUSED": {
				if(e.code == "EADDRINUSE"){
					console.log("ERROR: Address in use, trying next in sequence...");
				} else {
					console.log("ERROR: Connection refused, trying next in sequence...");
				}
				//Increase and loop serverID as necessary
				if(++this.sesKnow.serverID >= this.settings.port.length){
					this.sesKnow.serverID = 0;
				}
				setTimeout(this.restart,1000);
			}
		}
	},
	
	onClose: function(hadError){
		if("closedByError" in this){
			delete this.closedByError;
			this.restart();
		}
	},
});
