// Provides client-specific functionality
var core = require("./core"),
    net = require("net"),
    domain = require("domain"),
    _ = require("lodash");

function pong(data, irc) {
	console.log("PONG");
	irc.send("PONG", data);
}

module.exports = function Client(settings) {
	// settings {
	//     see Memory
	// }
	var self = this, quit = false;
	settings.irc = this;
	this.irc = new core.context(settings);
	var memory = this.memory = this.irc.memory;

	this.connect = function connect(connectedHandler) {
		function init () {
			self.info("Client initializing...");
			if(connectedHandler) self.connection.on("connected", connectedHandler);

			// Load modules
			var plugins = memory.plugins();
			for (var i = 0; i < plugins.length; ++i) {
				// No need to remember them really, we communicate with events
				require(process.cwd() + "/plugins/" + plugins[i])(self);
			}
			self.emit("modules-loaded");

			// Set up initial handlers...
			self.connection.on("initial", self.info);
			self.connection.on("initial", self.connection.reader(["numeric", "server", "client"]));

			self.connection.on("numeric", function (data) {
				// Parse the sender for more useful info
				data.sender = self.connection.read("sender", data.sender) || data.sender;

				// If we received the wrong nickname for whatever reason, it should be logged
				if (memory.my("nickname") != data.nick) self.warn({
					"what": "numeric",
					"which": self.connection,
					"message": "Destination of numeric does not seem to be me (received: '" + data.nick + "')",
				});

				// Try to parse the numeric and mix it into the data
				// NOTE: This may override <nick> but it's served its only usefulness
				if (data.inlay) {
					_.assign(data, self.connection.read(data.numeric, data.inlay));
					delete data.inlay;
				}

				// Send it back for other handlers
				data.event = data.numeric;
				return data;
			});

			self.connection.on("server", function (data) {
				// Parse the sender for more useful info
				data.sender = self.connection.read("sender", data.sender) || data.sender;

				// Try to parse the command and mix it into the data
				if (data.inlay) {
					_.assign(data, self.connection.read(data.command, data.inlay));
					delete data.inlay;
				}

				// Send it back for other handlers
				data.event = data.command;
				return data;
			});

			self.connection.on("client", function (data) {
				if (data.command != "PING") {
					self.warn("Received client packet that wasn't PING.");
					return false;
				}

				// Try to parse the command and mix it into the data
				if (data.inlay) {
					_.assign(data, self.connection.read(data.command, data.inlay));
					delete data.inlay;
				}

				// Send it back for other handlers
				data.event = data.command;
				return data;
			});

			self.connection.on("001", function (data) {
				// Successfully connected, wait for silence, then we can do stuff
				self.connection.onSilence(function () {
					self.connection.emit("connected", data);
				});
			});

			// and some other handlers...
			self.connection.on("PING", pong, self);
			//self.connection.passive("005", parseSupport, self.irc);

			// We want to rethrow specific versions of PRIVMSG and NOTICE
			self.connection.on("PRIVMSG", function (data) {
				if (data.sender.nick) {
					data.event = "PRIVMSG(" + data.sender.nick +")";
					return data;
				}
			});
			self.connection.on("NOTICE", function (data) {
				if (data.sender.nick) {
					data.event = "NOTICE(" + data.sender.nick +")";
					return data;
				}
			});

			// Initiate connection...
			self.info("Client logging in...");
			self.send("PASS", memory.my(["password"]));
			(function retryNICK() {
				self.send("NICK", memory.my(["nickname"]), { 
					"errors": ["433"],
					"failure": function nextNick() {
						var next = memory.nextNick(false);
						if (next === false) {
							// Garble a nick to get in for now...
							memory.my("nickname", memory.my("nicknames")[0] + _.random(100, 99999));
						}
						retryNICK();
					},
				});
			})();
			self.send("USER", memory.my(["username", "mode", "realname"]));
		}

		// Try each server
		function reconnect() {
			// Reset manual quit status when we reconnect
			quit = false;

			// Try to connect to the current address
			self.info("Connecting to " + memory.server("address") + ":" + memory.server("port").toString());
			socket = net.connect(memory.server("port"), memory.server("address"), init);

			// When this socket closes, we need to make sure it was intentional
			socket.on("close", function () {
				// If we didn't intend to disconnect, we should reconnect in a little bit.
				self.fail("Failed to connect!");
				if (!quit) {
					setTimeout(reconnect, memory.time("reconnect", 4000));
				}
			});

			// Store the connection
			self.connection = self.irc.connection(socket, "C2S");
		}

		var d = domain.create().on("error", function (e) {
			// If there was an error trying to connect, emit that fact
			if (["ECONNREFUSED", "ETIMEOUT", "ENOTFOUND"].indexOf(e.code) != -1) {
				self.connection.emit("connection-failed", {
					"server": memory.server,
					"errorCode": e.code,
				});

				// Try to connect to the next one soon
				setTimeout(function () {
					memory.nextServer(true);
					d.run(reconnect);
				}, memory.time("next-connection", 1000));
			} else {
				throw e;
			}
		}).run(reconnect);
	}

	// Wrappers
	this.send = function send(command, data) {
		data.command = command;
		data.inlay = memory.packet(command);
		if (!data.inlay) {
			self.fail("Failed to send packet ", command);
			return false;
		}
		self.connection.send("client", data);
	}

	this.message = function (target, text) {
		if (_.isObject(target)) {
			target = memory.packet("target").write(target);
			if (target === false) {
				self.fail("Bad target of message:" + JSON.serialize(target));
				return false;
			}
		}

		self.send("PRIVMSG", {
			"target": target,
			"text": text,
		});
	}

	this.on = function () { return self.connection.on.apply(this, arguments); }
	this.passive = function () { return self.connection.passive.apply(this, arguments); }
	this.off = function () { return self.connection.off.apply(this, arguments); }
	this.onSilence = function () { return self.connection.onSilence.apply(this, arguments); }
	this.emit = function () { return self.connection.emit.apply(this, arguments); }
	this.collect = function () { return self.connection.collect.apply(this, arguments); }
	this.read = function () { return self.connection.read.apply(this, arguments); }
	this.reader = function () { return self.connection.reader.apply(this, arguments); }

	// Logging
	this.fail = function fail(error) {
		// error { what, which, message }
		console.log("ERROR:", _.isObject(error) ? error.message : error);
	}

	this.warn = function warn(warning) {
		console.log("WARNING:", _.isObject(warning) ? warning.message : warning);
	}

	this.info = function info(information) {
		console.log("INFO:", _.isObject(information) ? information.message : information);
	}

	return this;
}