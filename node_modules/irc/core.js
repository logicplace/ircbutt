// Load in packets...
var Memory = require("memory"),
    fs = require("fs"),
    _ = require("lodash"),
    jslon = require("jslon");

function context(settings) {
	// settings {
	//     "irc": IRC instance
	//     See Memory
	// }
	var self = this, memory = this.memory = new Memory(settings);
	memory.installPackets(jslon.parse(fs.readFileSync(__dirname + "/base_protocol.json", "utf8")), "core");

	this.irc = settings.irc;

	this.connection = function connection(socket, type) {
		var handlers = {}, collections = {}, collectionQueue = [], collectID = 0, onSilence = [], silence = null;
		socket.setEncoding(memory.server("encoding"));

		// May be C2S, S2C, C2C, or S2S. Being C(lient) & S(erver), first being our side.
		this.type = type;

		var bufferedRaw = "", recvLock = false;
		socket.on("data", function (raw) {
			// Split received data and buffer any trailing bit that does not end with \r\n
			var data = raw.split("\r\n"),
			    remaining = data.splice(-1)[0];
			while (recvLock);
			recvLock = true;
			if (data.length) data[0] = bufferedRaw + data[0];
			if (remaining) bufferedRaw = remaining;

			for (var i = 0; i < data.length; ++i) {
				handleData("initial", data[i]);
			}
			recvLock = false;
		});

		function handleData(event, data) {
			// Run registered handlers.
			if (silence) clearInterval(silence);
			self.irc.info("Emitting event " + event);
			if (event in handlers) {
				// Copy to avoid race conditions with unregistering.
				var evhandlers = handlers[event].slice(0);
				for (var i = 0; i < evhandlers.length; ++i) {
					// Note that many handlers that rethrow just edit the event in the data
					// Since events are deleted before handling, there shouldn't be an issue
					var result = evhandlers[i].handler(data, evhandlers[i].userdata);
					if (result && !evhandlers[i].passive) {
						if ("event" in result && event != result.event) {
							var ev = result.event;
							delete result.event;
							handleData(ev, result);
						}
					}
				}
			}
			silence = setInterval(handleSilence, memory.time("silence", 2000));
		}

		function nextCollection() {
			// Triggered when a collection finishes. Check to see if any queued collections are read to go
			for (var i = 0; i < collectionQueue.length; ++i) {
				var c = collectionQueue[i], ok = true;
				for (var j = 0; j < c.waitFor.length; ++j) {
					if (hasResponse(c.waitFor[j])) {
						ok = false;
						break;
					}
				}

				// If it's ready to go
				if (ok) {
					// Run its handler
					c.handler();
					return true;
				}
			}

			if (collectionQueue.length) {
				// This should never be an issue
				self.irc.fail({
					"what": "nextCollection",
					"which": socket,
					"message": "Collection completed but no other collection could be run.",
				});
			}
		}

		function handleSilence() {
			if (onSilence.length) onSilence.shift()();
		}

		function getPacket(command, what, error) {
			var packet = memory.packet(command);

			if (!packet) {
				if (typeof(what) !== "undefined") {
					self.irc.fail({
						"what": what,
						"which": socket,
						"message": "Could not " + error + " '" + command + "' because " + (
							packet === 0 ? "it is not defined."
							: "it is not allowed by '" + memory.server("specification") + "'"
						),
					});
				}
				return false;
			}
			return packet;
		}

		function hasResponse(event) {
			if (!(event in handlers)) return false;

			var handler = handlers[event];

			for (var i = 0; i < handler.length; ++i) {
				if (handler[i].response) {
					return true;
				}
			}
			return false;
		}

		var out = {
			"on": function (event, handler, userdata) {
				// Register a handler. Of form {
				//     "handler": function to call,
				//     "passive": true asserts this will not make modifications to the packet (default: false),
				//     "userdata": extra data to pass to handler,
				//     "response": whether or not this is a response,
				//     "collection": collection ID to store
				// }
				if (_.isFunction(handler)) handler = { "handler": handler };
				else if (!_.isObject(handler)) {
					console.log("Bad handler???");
					return false;
				}
				_.defaults(handler, {
					"passive": false,
					"response": false,
					"userdata": userdata
				});

				if (event in handlers) {
					if (handler.response) handlers[event].unshift(handler);
					else handlers[event].push(handler);
				} else {
					handlers[event] = [handler];
				}
			},

			"passive": function (event, handler, userdata) {
				// Easy way to do a passive on
				if (_.isFunction(handler)) handler = { "handler": handler };
				handler.passive = true;
				return out.on(event, handler, userdata);
			},

			"off": function (events, handler) {
				// Here, handler is just the function.
				if (!_.isArray(events)) events = [events];

				for (var i = 0; i < events.length; ++i) {
					var event = events[i]
					if (event in handlers) {
						var newHandlers = [], check = (_.isNumber(handler) ? "collection" : "handler");
						for (var i = 0; i < handlers[event].length; ++i) {
							if (handlers[event][i][check] != handler) newHandlers.push(handlers[event][i]);
						}

						handlers[event] = newHandlers;
					}
				}
			},

			"onSilence": function (handler) {
				onSilence.push(handler);
			},

			"emit": function (event, data) {
				handleData(event, data);
			},

			"collect": function (options, handler) {
				// options {
				//     "start": Specifies the starting event for collection, may be undefined
				//     "events": Specifies the events to collect, besides start and end
				//     "end": Specifies the endind event for collection, may be undefined
				//     "errors": Specifies the events that indicate an error has occurred
				//     "multiError": true if multiple errors can be returned (default: false)
				//     "timeout": Custom timeout for endless or multiError forms
				//     "success": Handler for the success case, all collected packets will be sent to it
				//     "failure": Handler for the error case, ''
				//     "handler": Handler for either case, only called if success or failure is not defined
				//     "response": Whether or not this is a response
				// }
				// handler is called after registration is complete
				var registrations = [], collectionID = collectID++, waitFor = [];

				_.defaults(options, {
					"start": null,
					"events": [],
					"end": null,
					"errors": [],
					"multiError": false,
					"timeout": 1000,
					"response": false,
				});

				// Check if any of these events are already registered, if they are we need to wait.
				_.chain([options.start, options.events, options.end, options.errors])
				.flatten().each(function (event) {
					if (hasResponse(event)) waitFor.push(event);
				});

				// Instantiate the collection
				var c = collections[collectionID] = { "events": [], "errors": [] }, ending, started = false;

				function setupCollection() {
					if (options.start) {
						out.on(options.start, {
							"handler": afterStart,
							"userdata": true,
							"passive": !options.response,
							"response": options.response,
							"collection": collectionID,
						});
					} else {
						// Otherwise start now
						afterStart();
					}

					for (var i = 0; i < options.events.length; ++i) {
						out.on(options.events[i], {
							"handler": collectEvent,
							"userdata": options.events[i],
							"passive": !options.response,
							"response": options.response,
							"collection": collectionID,
						});
					}

					if (options.end) {
						out.on(options.end, {
							"handler": collectEnd,
							"passive": !options.response,
							"response": options.response,
							"collection": collectionID,
						});
					}

					for (var i = 0; i < options.errors.length; ++i) {
						out.on(options.errors[i], {
							"handler": collectError,
							"userdata": options.errors[i],
							"passive": !options.response,
							"response": options.response,
							"collection": collectionID,
						});
					}
				}

				function afterStart(data, fromStart) {
					c.start = data;
					started = true;

					// If this is from the start event...
					if (fromStart) {
						// ...the start event needs to be deregistered now
						out.off(options.start, collectionID);
					}

					// The timer needs to be started
					ending = setTimeout(timedOut, options.timeout);
				}

				function collectEvent(data, event) {
					if (started) {
						c.events.push([event, data]);
						resetWait();
					}
				}

				function collectError(data, event) {
					if (options.multiError) {
						c.errors.push([event, data]);
						resetWait();
					} else {
						c.error = data;
						deregisterCollection();
					}
				}

				function collectEnd(data) {
					if (started) {
						c.timedOut = false;
						c.end = data;
						deregisterCollection();
					}
				}

				function deregisterCollection() {
					out.off(options.events, collectionID);
					if (options.end) out.off(options.end, collectionID);
					if (options.errors) out.off(options.errors, collectionID);

					// Call handlers
					// Error case... if there was an error or unexpected timeout
					if (c.error || c.errors.length || (c.timedOut && options.end)) {
						if (options.failure) options.failure(c);
					} else if (options.success) {
						options.success(c);
					}

					if (options.handler) options.handler(c);

					// Signal to enable next collection
					nextCollection();
				}

				function resetWait() {
					clearTimeout(ending);
					ending = setTimeout(timedOut, options.timeout);
				}

				function timedOut() {
					c.timedOut = true;
					deregisterCollection();
				}

				if (waitFor) {
					collectionQueue.push({
						"id": collectionID,
						"wait": waitFor,
						"handler": setupCollection,
					});
					return false;
				}

				setupCollection();
			},

			"send": function (command, data, response) {
				// Lookup the packet.
				var packet = getPacket(command, "send", "send");
				if (!packet) return false;

				// If there is a response, we need to register it
				if (response) {
					response.response = true;
					out.collect(response, function () {
						var buffer = packet.write(data);
						if (buffer !== false) socket.write(buffer + "\r\n");
					});
				} else {
					// Otherwise just write it now.
					var buffer = packet.write(data);
					if (buffer !== false) socket.write(buffer + "\r\n");
				}
			},

			"read": function (command, data) {
				var packet = getPacket(command, "read", "read");
				if (!packet) return false;

				return packet.read(data);
			},

			"reader": function (command) {
				var packets = [];

				// Normalize command to array
				if (!_.isArray(command)) command = [command];

				// Retrieve all packets
				for (var i = 0; i < command.length; ++i) {
					var packet = getPacket(command[i], "reader", "create packet reader");
					if (!packet) return false;
					packets.push(packet);
				}

				// Generate function
				return function (data) {
					var result;
					// Try each packet
					for (var i = 0; i < packets.length; ++i) {
						result = packets[i].read(data);
						// Return the first success
						if (result) {
							result.event = command[i];
							return result;
						}
					}
					return result;
				}
			},
		};
		return out;
	}

	return this;
}

module.exports = {
	"context": context,
}