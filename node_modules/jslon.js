/* Extremely loose JSON interpreter.
 * Copyright 2011 Wa (logicplace.com)
 * MIT Licensed
 */
String.prototype.replace = require("strReplace");

var JSLONtoken = /[\[{\]},:]|\s+|\/\*[\s\S]*\*\/|\/\/.*|"(\\"|[^"]+)*"|'(\\'|[^']+)*'|\/(\\\/|[^\/]+)+\/[igm]+|[$_a-zA-Z][$_a-zA-Z0-9]*|[0-9]+\.[0-9]+|[0-9]+|0x[0-9]+/g

function JSLONusO(m)return String.fromCharCode(parseInt(m[1],8));
function JSLONusX(m)return String.fromCharCode(parseInt(m[1],16));
function JSLONusU(m)return String.fromCharCode(parseInt(m[1],16));
function JSLONunescapeString(string){
	return string
	.replace(/\\n/g,"\n")
	.replace(/\\t/g,"\t")
	.replace(/\\r/g,"\r")
	.replace(/\\f/g,"\f")
	.replace(/\\b/g,"\b")
	.replace(/\\[0-3]?[0-7]{0,2}/g,JSLONusO)
	.replace(/\\x[0-9a-fA-F]{2}/g,JSLONusX)
	.replace(/\\u[0-9a-fA-F]{4}/g,JSLONusU)
	.replace(/\\(.)/g,"\\1")
	;
}

function JSLONparse(string){
	var tokens = string.match(JSLONtoken),ret,parents=[],cur=null,curIdx=null;
	if(!tokens)throw new SyntaxError("Unable to tokenize");
	
	//console.log(tokens);
	
	function set(x,key){
		if(key == ":"){
			curIdx = x;
		} else {
			if(curIdx != null){
				cur[curIdx] = x;
				curIdx = null;
			}
			else if(cur != null)cur.push(x);
			else ret = x;
			if(typeof(x) == "object"){
				parents.push(cur);
				cur = x;
			}
		}
	}
	
	function up(nom){
		if(parents.length == 0){
			throw new SyntaxError("Ending "+nom+" without a beginning.");
		}
		cur = parents.pop();
	}
	
	for(var i=0;i<tokens.length;++i){
		var token = tokens[i];
		switch(token.charAt(0)){
			case ":": break; //Already taken care of
			case "{": set({}); break;
			case "[": set([]); break;
			case "}": up("brace"); break;
			case "]": up("bracket"); break;
			case ",":
				if(cur == null)throw new SyntaxError("Unexpected comma.");
				break;
			case "/":
				//Check if it's a comment
				var c2 = token.charAt(1);
				if(c2 == "*" || c2 == "/")break;
				var end = token.lastIndexOf("/");
				//Make regex
				set(new RegExp(token.slice(1,end).replace("\\/","/"),token.slice(end+1)));
				break;
			case "'":
				set(JSLONunescapeString(token.slice(1,-1)),tokens[i+1]);
				break;
			case '"':
				set(JSLONunescapeString(token.slice(1,-1)),tokens[i+1]);
				break;
			default:
				if(token.match(/^\s+$/))break; //Whitespace
				if(token.slice(0,2) == "0x"){ //Hex
					set(parseInt(token.slice(2),16));
				}else if(token.match(/^[0-9.]+$/)){ //Number
					if(token.indexOf(".") != -1)set(parseFloat(token));
					else if(token.charAt(0) == "0")set(parseInt(token.slice(1),8));
					else set(parseInt(token));
				}else{ //Key/literal (variable name limitations)
					set(token,tokens[i+1]);
				}
				break;
		}
	}
	return ret;
}

function JSLONstringify(obj,options){
	/* Options:
	*) quotes: ' or " (default)
	*) keyQuotes: true (default)/false //true if keys are always quoted
	*) numBase: 8, 10 (default), or 16
	*) TODO: prettyprint options
	*) entriesPerLine: 0 (default, meaning all), 1+
	*) openOwnLine: true/false (default) //Only refers to contents being on a different line as [ or {
	*) endOwnLine: true/false (default)
	*) keyOwnLine: true/false (default) //true if value and key are on different lines
	*) specific: null (default) //Object mimicing partial structure of obj, defining the above
	//+at specific points
	*/
}

if(typeof(module) != "undefined"){
	module.exports = {
		parse: JSLONparse
	}
}
